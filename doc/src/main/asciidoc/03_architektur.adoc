== Architektur
:source-dir: ../java

=== Übersicht

Linkki erstellt aus UI-Definitionen (in Form von Annotations an Presentation-Model-Objekten) ein UI, dessen Inhalte (Daten) und Eigenschaften (z.B. Sichtbarkeit, Editierbarkeit, ...) bidirektional an Methoden der PMOs gebunden werden. Wird ein Wert im UI vom Benutzer verändert, werden auch davon abhängige Eigenschaften und damit andere UI Elemente aktualisiert.

.Bidirektionales Databinding
image::data_binding.png[]
 
 TODO: Auf die Kapitel eingehen - erst sinnvoll wenn deren Inhalt fest steht.
 
[[databinding]]
=== Data Binding mit PMOs

Ein Presentation Model Object kapselt den Zustand des UIs unabhängig von der konkreten UI-Implementierung. Das UI interagiert über Data Binding ausschließlich mit diesem PMO. Dazu muss das PMO nicht alle Daten selber halten - häufig delegiert es an ein oder mehrere bestehende Modellobjekte (siehe <<domain-model-binding,Daten auf mehreren Ebenen>>) und/oder aggregiert und konvertiert Daten zur Darstellung im UI.

.Presentation Model Object
image::pmo.png[]

In Linkki sind PMOs POJOs, die mit `@UISection` annotiert sind - es gibt also für jeden Abschnitt des UIs ein eigenes PMO. Alle an das UI zu bindenden Methoden erhalten passende Annotationen (siehe dazu <<ui-komponenten,UI Komponenten>>). Zusätzlich gibt es ein paar Interfaces, die PMOs implementieren können: 

* `org.linkki.core.PresentationModelObject` bietet eine Methode, mit der ein Button-PMO erstellt werden kann; der daraus erzeugte Button löst eine Bearbeitung des PMOs aus
* `org.linkki.core.ButtonPmo` ist ein PMO für Buttons, siehe <<buttons,Buttons>>
* `org.linkki.core.ui.table.ContainerPmo` ist ein PMO für Tabellen - die einzelnen Zeilen haben wieder reguläre PMOs, siehe auch <<container-komponenten,Container Komponenten>>

=== Grundaufbau BindingContext - BindingManager

Alle Bindings in Linkki sind Teil eines `BindingContext`. Üblicherweise verbindet ein `BindingContext` alle Bindings auf einer Seite oder in einem thematisch unabhängigen Abschnitt. Bei Änderungen an einem gebundenen Objekt (PMO oder UI) werden alle Bindings im gleichen Kontext aktualisiert. Mehrere PMOs (und damit UI-Abschnitte) können mit dem gleichen `BindingContext` gebunden werden.

.BindingContext und ~Manager
image::binding_context_manager.png[]

Um einen oder mehrere `BindingContext` zu erstellen und verwalten gibt es einen `BindingManager`. Dieser gibt zu einem Namen (ggf. abgeleitet von einer Klasse) einen `BindingContext` zurück - oder erstellt bei Bedarf einen neuen. In Ableitungen von `BindingManager` kann festgelegt werden, welches Verhalten die vom jeweiligen `BindingContext` erstellten Bindings haben sollen (siehe <<vertikales-binding,Vertikales Binding>>). Soll kein besonderes Verhalten implementiert werden genügt ein `DefaultBindingManager`. Ein `BindingManager` wird üblicherweise `@ViewScoped` angelegt und jeder `Page` (siehe <<page,Page>>) übergeben.  

Ein besonderer `BindingManager` ist der `DialogBindingManager`, der dafür sorgt, dass bei jeder Änderung auch die Validierungsmethode des Dialogs aufgerufen wird.

[[domain-model-binding]]
=== Daten auf mehreren Ebenen (Domain Model Binding)

Domain Model Binding, oder kurz "Model Binding", ist ein Linkki Feature zur Vermeidung unnötigen Codes in PMO Klassen. Es zielt auf den "einfachen" Fall bei der Anbindung von UIs ab, in dem Eigenschaften aus dem Domain Model unverändert an der Oberfläche angezeigt werden. Unverändert bedeutet, dass das PMO keine Umformattierung oder andere Konvertierungen durchführen muss, bevor Werte in der UI angezeigt werden können. 

Beispielsweise benötigt der Vorname einer Person keinerlei Umformattierung:

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonPmo.java[tags=pojo-binding]
----

Das selbe Verhalten unter Verwendung des Model Bindings:

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonPmo.java[tags=model-binding]
----
Model Binding vermeidet unnötigen Delegations-Code und ist damit eine Art "Abkürzung".

.Model Binding
image::ModelBinding.png[]

==== Namen von Modell-Attirbuten angeben

Um das Model Binding Feature verwenden zu können, muss in der UI Annotation die Eigenschaft `modelAttribute` angegeben werden. Der Datentyp der Eigenschaft ist String. Der Wert von `modelAttribute` gibt an, wie die entsprechende Property in der Domain Model Klasse heißt. Existiert keine entsprechende Eigenschaft an der Domain Model Klasse, so wird bei der Erstellung der Oberfläche eine Exception geworfen.

Sobald `modelAttribute` angegeben wird, ignoriert Linkki sowohl den Rückgabewert als auch den Inhalt der Methode im PMO. Daher kann als Rückgabetyp `void` angegeben, und der Methodenrumpf leer gelassen werden. Von nun an wird vom Data Binding nicht mehr die Methode im PMO aufgerufen, sondern immer direkt die entsprechende Methode im Domain Model.

Im obigen Beispiel heißt die Methode im PersonPMO `vorname()`. Im Domain Model dagegen heißt sie `firstname` bzw. `getFirstname()`. Es ist also möglich, Properties in PMO und Domain Model unterschiedlich zu benennen.

==== Mehrere Modellobjekte

Model Binding kann auch dann zum Einsatz kommen, wenn ein PMO mehrere Modellobjekte verwendet. In diesem Fall kann in der UI Annotation die Eigenschaft `modelObject` angegeben werden. Der Datentyp der Eigenschaft ist ebenfalls String. Der Wert von `modelObject` gibt an, welches Model Object des PMOs für Model Binding verwendet werden soll. Als Identifikator von Modellobjekten wird der in der `@ModelObject` Annotation angegebene Name verwendet.

[source,java]
----
include::{source-dir}/org/linkki/doc/ContractPmo.java[tags=class]
----

Im obigen Beispiel definiert die Annotation von `vornameVersichertePerson()`, dass die Property `firstname` an Modellobjekt `VP` aufgerufen werden soll. Um einen Wert zur Darstellung in der Oberfläche zu ermitteln, geht das Databinding folgendermaßen vor:

* Aufrufen der Methode `getInsuredPerson()` am PMO, da diese Methode mit `@ModelObject("VP")` annotiert ist
* Speichern des zurückgegebenen Person-Objekts
* Aufrufen des Getters für `firstname` am ermittelten Person-Objekt

Wird in der Annotation keine Eigenschaft `modelObject` angegeben, so wird die Methode aufgerufen, die mit `@ModelObject` (ohne weiteren Namen) annotiert wurde. Dementsprechend wird für `vornameVersicherungsnehmer()` das Modellobjekt über `getPolicyHolder()` ermittelt.  
  
[[binding-ui-element-properties]]
=== Binding von UI Elementen Eigenschaften und Daten (auswählbare Werte, Enabled, Sichtbarkeit, ToolTip)

[[vertikales-binding]]
=== Vertikales Binding