== Architektur
:source-dir: ../java

=== Übersicht

Zentrale Punkte des *linkki* Frameworks sind

* die deklarative Definition von UIs mittels Annotationen
* das flexible Databinding

*linkki* ermöglicht eine deklarative Definition von Oberflächen, indem Benutzeroberflächen automatisch aus Annotationen erstellt werden. Unabhängig von der Erstellung können außerdem die Inhalte (Daten) eines UI-Elements und deren Eigenschaften (z.B. Sichtbarkeit, Editierbarkeit, ...) an sogenannte Presentation Model Objects (PMOs) gebunden werden. Dadurch entsteht ein bidirektionaler update-Mechanismus, das sogenannte Databinding. Wird beispielsweise ein Wert im UI vom Benutzer verändert, werden sowohl der betreffende Wert im Domain Model, als auch davon abhängige Eigenschaften und damit ebenso andere UI-Elemente aktualisiert.

.Bidirektionales Databinding
image::data_binding.png[]

Im ersten Teil dieses Kapitles gehen wir auf den <<grundaufbau-binding, Grundaufbau des `BindingContext` und `BindingManager`>> ein, und darauf wie sie zusammenarbeiten.

Im den folgenden Abschnitten wird das <<databinding, Databinding mit PMOs>> beschrieben. Dies können simple PMOs sein, in denen die Werte verwaltet werden, oder <<domain-model-binding, PMOs mit Domain Model Binding>> in denen die Werte direkt an das Domain Model gebunden werden. Das 'Binding' <<modell-attribut-namen, mehrerer Modelobjekte>> in einem PMO wird ebenfalls erklärt.

Welche Eigenschaften der definierten UI-Elemente gesteuert werden können, und welche weiteren Möglichkeiten *linkki* zur Verfügung stellt, wird im Abschnitt <<binding-ui-element-properties, Binding von weiteren UI-Element-Eigenschaften>> beschrieben.

Am Ende des Kaptiels <<architektur, Architektur>> werden noch sogenannte <<querschnittsaspekte-im-binding, Querschnittsaspekte im Databinding>> erläutert.

[[grundaufbau-binding]]
=== Binding, BindingContext, BindingManager

Für jede UI-Komponente, die an einem PMO gebunden wird, erstellt *linkki* ein sogenanntes `Binding`. Bei Änderungen im PMO wird über die Methoden des `Bindings` sichergestellt, dass die UI-Komponente korrekt aktualisiert wird.

Alle Bindings in *linkki* sind Teil eines `BindingContext`. Üblicherweise verbindet ein `BindingContext` alle Bindings auf einer Seite oder in einem thematisch unabhängigen Abschnitt. Bei Änderungen an einem gebundenen Objekt (PMO oder UI) werden alle Bindings im gleichen Kontext aktualisiert. Mehrere PMOs können mit dem gleichen `BindingContext` gebunden werden.

.BindingContext und ~Manager
image::binding_context_manager.png[]

Um einen oder mehrere `BindingContext` zu erstellen und zu verwalten, gibt es einen `BindingManager`. Dieser gibt zu einem Namen (ggf. abgeleitet von einer Klasse) einen `BindingContext` zurück, oder erstellt bei Bedarf einen neuen. In Ableitungen von `BindingManager` kann festgelegt werden, welches Verhalten die vom jeweiligen `BindingContext` erstellten Bindings haben sollen (siehe <<vertikales-binding,Vertikales Binding>>). Soll kein besonderes Verhalten implementiert werden genügt ein `DefaultBindingManager`. Ein `BindingManager` wird üblicherweise `@ViewScoped` angelegt und jeder `Page` (siehe <<page,Page>>) übergeben.  

Ein besonderer `BindingManager` ist der `DialogBindingManager`, der dafür sorgt, dass bei jeder Änderung auch die Validierungsmethode des Dialogs aufgerufen wird.

[[databinding]]
=== Data Binding mit PMOs

Ein Presentation Model Object kapselt den Zustand des UIs unabhängig von der konkreten UI-Implementierung. Das UI interagiert über Data Binding ausschließlich mit diesem PMO. Dazu muss das PMO nicht alle Daten selber halten, sondern kann direkt an ein oder mehrere bestehende Modellobjekte deligieren (siehe <<domain-model-binding,Daten auf mehreren Ebenen>>). Diese Daten werden dann in ein für die Anzeige geeignetes Format konvertiert.

In *linkki* sind PMOs Plain Old Java Objects (POJOs), in der Daten für einzelne UI Abschnitte organisiert sind. Zu jedem Abschnitt des UIs soll es also ein eigenes PMO geben.

Ausschlaggebend für das Data Binding sind sogenannte "Properties" eines PMOs. Eine PMO Klasse besitzt ein Property names "property" genau dann, wenn diese Klasse eine Methode `getProperty`  hat. Falls der Wert dieses Propertys modifizierbar sein soll, muss es zusätzlich eine Methode `setProperty` geben. Oft wird der Wert des Propertys in eine Klassenvariable `property` gespeichert. Dies ist an die Namenkonventionen für JavaBean Properties angelehnt. Die PMO Klassen müssen allerdings selbst keine JavaBeans sein.

Betrachte zum Beispiel die folgende Klasse:

```java
include::{source-dir}/org/linkki/doc/BeispielPmo.java[tags=class]
```

Diese Klasse hat zwei Properties: "anrede" und "namensanzeige". Am Property "namesanzeige" sieht man, dass es zu einem PMO Property nicht zwingend eine Klassenvariable geben muss. Hingegen ist "nachname" kein Property der Klasse, obwohl es dazu eine Klassenvariable und eine passende Setter-Methode gibt, denn es fehlt die notwendige Methode `String getNachname()`.


Es gibt einige Interfaces, die PMO Klassen optional implementieren können: 

* `org.linkki.core.PresentationModelObject` bietet eine Methode, mit der ein Button-PMO erstellt werden kann; der daraus erzeugte Button löst eine Bearbeitung des PMOs aus
* `org.linkki.core.ButtonPmo` ist ein PMO für Buttons, siehe <<ui-button,Buttons>>
* `org.linkki.core.ui.table.ContainerPmo` ist ein PMO für Tabellen - die einzelnen Zeilen haben wieder reguläre PMOs, siehe auch <<container-komponenten,Container Komponenten>>

[[domain-model-binding]]
=== Daten auf mehreren Ebenen (Domain Model Binding)

Domain Model Binding, oder kurz "Model Binding", ist ein *linkki* Feature zur Vermeidung unnötigen Codes in PMO Klassen. Es zielt auf den "einfachen" Fall bei der Anbindung von UIs ab, in dem Eigenschaften aus dem Domain Model unverändert an der Oberfläche angezeigt werden. Unverändert bedeutet, dass das PMO keine Umformattierung oder andere Konvertierungen durchführen muss, bevor Werte in der UI angezeigt werden können. 

Um dieses Feature nutzen zu können, muss das UI mittels <<pmo-uisection,`@UISection`>> erstellt werden. Die Getter-Methode für das Modellobjekt im PMO muss dann mit der Annotation `@ModelObject` markiert werden. 

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonPmo.java[tags=modelobject]
----

Beispielsweise kann der Vorname aus dem Modell ohne Modifizierung direkt für die Anzeige verwendet werden:

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonPmo.java[tags=pojo-binding]
----

In diesem Fall stellt die Getter-Methode eine direkte Delegation an ein Modellattribut dar. Daher kann das gleiche Verhalten unter Verwendung des Model Bindings erzielt werden:

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonPmo.java[tags=model-binding]
----
Model Binding vermeidet unnötigen Delegations-Code und ist damit eine Art "Abkürzung".

.Model Binding
image::ModelBinding.png[]

[[modell-attribut-namen]]
==== Namen von Modell-Attribut

Um das Model Binding Feature verwenden zu können, muss in der <<ui-element,UI Annotation>> die Eigenschaft `modelAttribute` angegeben werden. Der Datentyp der Eigenschaft ist `String` . Der Wert von `modelAttribute` gibt an, wie die entsprechende Property in der Domain Model Klasse heißt. Existiert keine entsprechende Eigenschaft an der Domain Model Klasse, so wird bei der Erstellung der Oberfläche eine Exception geworfen.

Sobald `modelAttribute` angegeben wird, ignoriert *linkki* sowohl den Rückgabewert als auch den Inhalt der Methode im PMO. Daher kann als Rückgabetyp `void` angegeben, und der Methodenrumpf leer gelassen werden. Von nun an wird vom Data Binding nicht mehr die Methode im PMO aufgerufen, sondern immer direkt die entsprechende Methode im Domain Model.

Im obigen Beispiel heißt die Methode im `PersonPMO` `vorname()`. Im Domain Model dagegen heißt sie `firstname` bzw. `getFirstname()`. Es ist also möglich, Properties in PMO und Domain Model unterschiedlich zu benennen.

TIP: *linkki* sucht im Modell nach allen benötigten Methoden. Falls die Setter-Methode ignoriert werden soll, muss auf die Benutzung der Abkürzung verzichten werden. Hingegen kann auch bei annotierten Getter-Methoden ein Modellattribut angegeben werden. Dadurch wird im Modell nach allen Methoden gesucht, die *linkki* im PMO nicht finden kann.

Zu Beachten ist dabei, dass die Benennung der Methode nicht ohne Auswirkung ist. Wenn `modelAttribute` bei der Annotation angegeben ist, wird der ganze Methodenname als ein PMO Property behandelt. Der Name des Properties wird verwendet um <<ui-properties,UI Eigenschaften>> wie <<enabled, Editierbarkeit>>, <<visible, Sichtbarkeit>> oder <<available-values,auswählbare Werte>> zu binden.

==== Mehrere Modellobjekte

Model Binding kann auch dann zum Einsatz kommen, wenn ein PMO mehrere Modellobjekte verwendet. In diesem Fall kann in der UI Annotation die Eigenschaft `modelObject` angegeben werden. Der Datentyp der Eigenschaft ist ebenfalls String. Der Wert von `modelObject` gibt an, welches Model Object des PMOs für Model Binding verwendet werden soll. Als Identifikator von Modellobjekten wird der in der `@ModelObject` Annotation angegebene Name verwendet.

[source,java]
----
include::{source-dir}/org/linkki/doc/ContractPmo.java[tags=class]
----

Im obigen Beispiel definiert die Annotation von `vornameVersichertePerson()`, dass die Property `firstname` an Modellobjekt `VP` aufgerufen werden soll. Um einen Wert zur Darstellung in der Oberfläche zu ermitteln, geht das Databinding folgendermaßen vor:

* Aufrufen der Methode `getInsuredPerson()` am PMO, da diese Methode mit `@ModelObject("VP")` annotiert ist
* Speichern des zurückgegebenen Person-Objekts
* Aufrufen des Getters für `firstname` am ermittelten Person-Objekt

Wird in der Annotation keine Eigenschaft `modelObject` angegeben, so wird die Methode aufgerufen, die mit `@ModelObject` (ohne weiteren Namen) annotiert wurde. Dementsprechend wird für `vornameVersicherungsnehmer()` das Modellobjekt über `getPolicyHolder()` ermittelt.  
  
[[binding-ui-element-properties]]
=== Binding von weiteren UI-Element-Eigenschaften

Neben dem anzuzeigenden Wert können weitere Eigenschaften der UI-Elemente per Databinding an Methoden des PMO gebunden werden. Die genaue Funktionsweise wird im Kapitel <<ui-komponenten, UI-Komponenten>> näher beschrieben.

[[querschnittsaspekte-im-binding]]
=== Querschnittsaspekte im Databinding

Zum Großteil bestimmen Informationen aus PMOs und Domain Model den Zustand der UI. In vielen Anwendungen jedoch muss die Oberfläche zusätzlich durch andere Informationen, z.B. den Systemzustand beeinflusst werden. Diese Informationen nennen wir im Folgenden _Querschnittsaspekte_.

Das Standardbeispiel für einen Querschnittsaspekt ist der "Browse Mode". Viele Anwendungen unterscheiden zwischen:

* Editiermodus ("Edit Mode"), in dem Informationen in der Oberfläche eingegeben und verändert werden können
* Ansichtsmodus ("Browse Mode"), in dem Daten in Formularen zwar angezeigt werden, aber schreibgeschützt sind

Häufig wechseln Anwendungen zwischen diesen Modi hin und her, z.B. indem eine "Änderung" begonnen oder abgeschlossen wird. 
Im Browse Mode gilt, dass alle Felder in Formularen schreibgeschützt sind. Dieser globale Bearbeitungszustand der Anwendung beeinflusst also viele Felder gleichzeitig. Zusätzlich überstimmt der Browse Mode die Einstellungen aus PMOs. Selbst wenn ein PMO ein Feld als editierbar angibt, ist es im Browse Mode schreibgeschützt.

Auf technischer Ebene existieren zwei Linkki-Konstrukte, um Querschnittsaspekte abzubilden: `PropertyDispatcher` und `PropertyBehaviors`.

==== PropertyDispatcher

Der `BindingContext` (siehe <<grundaufbau-binding,Grundaufbau BindingContext - BindingManager>>) verwendet eine `PropertyDispatcherFactory`, die mehrere miteinander verknüpfte `PropertyDispatcher` erstellt. Diese Dispatcher wiederum werden zum Binden der Properties und ihrer Eigenschaften (siehe <<binding-ui-element-properties,Binding von weiteren UI-Element-Eigenschaften>>) verwendet. `PropertyDispatcher` haben Methoden zur Abfrage von Datentyp und Wert einer Property, sowie der zugehörigen Eigenschaften. Standardmäßig werden in *linkki* vier miteinander verknüpfte Dispatcher erstellt, die jeweils an den Nächsten delegieren, wenn sie selbst den Wert nicht liefern können: 

* `BehaviorDependentDispatcher` verwendet `PropertyBehaviors` (siehe im nächsten Abschnitt, <<property-behavior,PropertyBehaviors>>)
* `BindingAnnotationDispatcher` liefert Informationen die aus den UI-Annotationen direkt abgelesen werden können
* `ReflectionPropertyDispatcher` greift per Reflection auf die aus dem Propertynamen abgeleiteten Methoden am PMO bzw. Domain Model zu
* `ExceptionPropertyDispatcher` wirft eine Exception, falls die entsprechende Eigenschaft nicht verfügbar ist - dies deutet häufig auf einen Tippfehler in einem Methodennamen hin, aufgrunddessen der `ReflectionPropertyDispatcher` die passende Methode nicht finden kann

.Beispiel für PropertyDispatcher
image::vertical_binding.png[]

Eigene Dispatcher können über eine eigene `PropertyDispatcherFactory` (in einem eigenen `BindingContext`) erstellt werden. Dort muss die Methode `createCustomDispatchers` überschrieben werden, um einen oder mehrere eigene Dispatcher bereitzustellen. Diese anwendungsspezifischen Dispatcher werden zwischen `BehaviorDependentDispatcher` und `BindingAnnotationDispatcher` eingehängt.

[[property-behavior]]
==== PropertyBehaviors

PropertyBehaviors werden von einem `PropertyBehaviorProvider` erstellt, der dem `BindingContext` als Konstruktor-Parameter übergeben werden kann. Welche `PropertyBehaviors` verwendet werden, kann also von der Anwendung konfiguriert werden.

Über `PropertyBehaviors` kann ein `BehaviorDependentDispatcher` das Verhalten von Eigenschaften steuern. Nur eine Auswahl der Eigenschaften sind darüber steuerbar: Sichtbarkeit (`isVisible`), Editierbarkeit (`isWritable`) und Anzeige von Fehlern (`isShowValidationMessages`). Dazu werden alle `PropertyBehaviors` aufgerufen; geben sie einstimmig `true` zurück, leitet der `BehaviorDependentDispatcher` die Anfrage an den nächsten `PropertyDispatcher` weiter, ansonsten gibt er direkt `false` bzw. eine leere Fehlerliste zurück, oder setzt den Wert nicht.

.Veto eines PropertyBehaviors
image::property_behavior_veto.png[]

Für eigene Verhaltensweisen kann das Interface `PropertyBehavior` implementiert werden. So kann zum Beispiel eine komplette Seite in einen Lese- oder Schreibmodus versetzt werden:

[source,java]
----
include::{source-dir}/org/linkki/doc/ReadOnlyBehavior.java[tags=class]
----
 