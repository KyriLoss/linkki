== Erstellung eines UI mit Linkki
:source-dir: ../../../../samples/binding/src/main/java

Mit *linkki* git es 2 Möglichkeiten ein UI aufzubauen:

1. <<pmo-uisection, mittels `@UISection` am PMO>>
2. <<manual-binding, manuelles Binding über `@Bind`>>

[[pmo-uisection]]
=== PresentationModelObject mit `@UISection`

Wird eine Klasse mit `@UISection` annotiert, übernimmt linkki die Kontrolle über die Erstellung und Anordnung der definierten Komponenten. Über die Annotation für die zugehörigen <<missing-link, `UIElemente`>> können bestimmte Aspekte definiert und/oder gesteuert werden. Die `@UISections` werden über <<missing-link, `SectionFactories`>> erstellt.

Die <<missing-link, `UIElemente`>> werden entweder an die 'properties' eines <<binding-modelObjet, `ModelObjects`>> oder eines PMO's gebunden.

Im <<abschnitt-form-binding, ersten Abschnitt>> wird die Erstellung einer `@UISection` eines 'standard' Formulars beschrieben. Im <<abschnitt-binding-table, zweiten Abschnitt>> wird das erstellen einer `@UISection` mit einer Tabelle erleutert.

[[abschnitt-form-binding]]
==== Binding eines Formulars

[[binding-modelObject]]
.Binding mit `@ModelObject`
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonPmo.java[tags=personPmo-class]
----
TIP: die Definition von `modelAttribute` ist optional, wenn der Feldname im `ModelObject` und der Name der annotierten Methode gleich sind.

[[abschnitt-binding-table]]
==== Binding einer Tabelle

Um eine `@UISection` mit einer Tabelle zu erzeugen muss die annotierte Klasse <<missing-link, `org.linkki.core.ui.table.ContainerPmo<T>`>> implementieren. Der `Generic`-Parameter `T` repräsentiert den Typ des PMOs um eine Zeile in dieser Tabelle zu erzeugen.

[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonTablePmo.java[tags=personTablePmo-class]
----

Die Methode `getItems()` gibt die Zeilen der Tabelle in Form der vorher mit `T` spezifizierten 'Row PMOs' zurück.

[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonTablePmo.java[tags=personTablePmo-getItems]
----

Im `interface ContainerPmo<T>` werden noch weitere `default` Methoden spezifiziert. Eine genaue Beschreibung befindet sich <<missing-link, hier>>.

Das sogenannte 'Row PMO' ist grundsätzliche ein gewöhnliches PMO wie in <<abschnitt-form-binding, Abschnitt 1>> beschrieben. Die einzige Besonderheit ist, dass die `UIElemente` ebenfalls mit der Annotation <<missing-link, `@UITableColumn`>> gekennzeichnet sind.


[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonRowPmo.java[tags=personRowPmo-labelBinding]
----

Es können alle `UIElemente` ebenfalls in Tabellen verwendet werden. Ein Binding eines `@UIButton` sieht folgendermaßen aus:

[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonRowPmo.java[tags=personRowPmo-buttonBinding]
----

NOTE: In unserem Beispiel sollen die Elemente in der Tabelle 'read-only' dargestellt werden. Deswegen erfolgt kein direktes Binding des `ModelObject` über eine mit `@Model` annotierte Methode.

IMPORTANT: In allen Fällen gilt: existiert im `ModelObject` oder PMO kein 'Setter' dann ist das Feld `readOnly`

[[manual-binding]]
=== Manuelles Binding mit `@Bind`

Auf Grund spezieller Anforderungen oder spezieller eigener `Fields` ist es manchmal nicht möglich den <<pmo-uisection, automatischen Aufbau über `@UISection`>> zu nutzen. Für diesen Fall besteht die Möglichkeit, dass *linkki* 'nur' das Data-Binding übernimmt. Man behält somit die volle Kontrolle über die Erstellung, Anordnung und Konfiguration (z.B. `setNullRepresentation()` oder `setConverter()`) der Komponenten.

Für die Aktivierung des manuellen Bindings muss die Annotation `@Bind` auf die Komponente geschrieben werden. Es können sowohl Felder als auch Methoden annotiert werden. Unterstützte Typen sind:

* `com.vaadin.ui.Field`
* `com.vaadin.ui.Label`
* `com.vaadin.ui.Button`

Danach kann das Data-Binding über den <<missing-link, `Binder`>> erstellt werden.


.@Bind auf Felder
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/components/AddressFields.java[tags=addressFields-class]
----

.@Bind auf Methoden
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/components/AddressFields2.java[tags=addressFields-methodBinding]
----

TIP: wenn das Data-Binding von Vaadin-Komponenten einer verwendeten Library von *linkki* übernommen werden soll, kann dies durch Vererbung oder 'delegete proxies' und `@Bind` auf den Methoden aktiviert werden.

.Binding aktivieren
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/components/ContactComponent.java[tags=manual-binding]
----

<<missing-link, Hier>> ist ein Beispielprojekt mit den verschiedenen Binding-Möglichkeiten.

[TIP]
====
Binding-Zusammenfassung:

* `@UISection` -> einfaches, schnelles Template mit eingeschränkten Konfigurationsmöglichkeiten
* manuelles Binding -> volle Kontrolle

*linkki* arbeitet mit bestimmten <<missing-link, Namenskonventionen>>. Dadurch verringern sich die Fehlerquellen und der refactoring Aufwand.

Die in den Annotationen verwendeten Werte für `pmoProperty` bzw. `modelAttribute` sollten in Konstanten der jeweiligen Klasse ausgelagert werden.
