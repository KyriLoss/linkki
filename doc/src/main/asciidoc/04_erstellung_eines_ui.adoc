[[ui-erstellung]]
== Erstellung eines UI mit linkki
:source-dir: ../../../../samples/binding/src/main/java

Mit *linkki* git es zwei Möglichkeiten ein UI zu erstellen:

1. <<pmo-uisection, mittels `@UISection` am PMO>>
2. <<manual-binding, manuelles Binding über `@Bind`>>

Im ersten Fall wird automatisch eine sogenannte _Section_ erzeugt, in der UI-Elemente organisiert werden. Die zweite Option überlässt die Erstellung der UI-Elementen ganz dem Anwender.

=== Section

Eine Gruppe von Eingabefeldern oder eine Tabelle wird als _Section_ bezeichnet. Eine Section kann einen Titel haben und wird in diesem Fall auch optisch durch eine Linie in der Titelleiste abgegrenzt. Wenn eine Section keinen Titel hat, ist sie optisch im fließenden Layout nicht direkt zu erkennen.

Eine Section legt außderdem fest, in welcher Anordnung der Inhalt dargestellt werden soll: horizontal oder vertikal. Im horizontalen Layout werden alle Eingabefelder in einer Zeile, nebeneinander dargestellt. Im vertikalen Layout werden die Felder untereinander dargetstellt. Wenn zusätzlich eine Anzahl von Spalten durch die Eigenschaft `columns` festgelegt wird, wird zeilenweise (links-rechts) eine Art Grid Layout aufgebaut.

Die Section kann anstatt mehrere Eingabefelder auch eine Tabelle enthalten und wird dann als _TableSection_ genannt.

[[pmo-uisection]]
=== PresentationModelObject mit `@UISection`

Wird eine Klasse mit `@UISection` annotiert, übernimmt *linkki* die Kontrolle über die Erstellung und Anordnung der definierten Komponenten. Über die Annotation für die zugehörigen <<ui-element, UI-Elemente>> können bestimmte Aspekte definiert und/oder gesteuert werden. Die Sections werden über <<missing-link, `SectionFactories`>> erstellt.

Die <<ui-element, `UI-Elemente`>> werden entweder an die 'properties' eines <<binding-modelObjet, `ModelObject`>>s oder eines PMO's gebunden. Eine detaillierte Beschreibung gibt es im Kapitel <<domain-model-binding, `Daten auf mehreren Ebenen`>>.

TIP: In allen Fällen gilt: existiert im `ModelObject` oder PMO kein 'Setter', dann ist das Feld `readOnly`

Im <<abschnitt-form-binding, ersten Abschnitt>> wird beispielhaft die Erstellung einer Section eines 'standard' Formulars beschreibt. Im <<abschnitt-binding-table, zweiten Abschnitt>> wird das erstellen einer Section mit einer Tabelle erleutert.

[[abschnitt-form-binding]]
==== Binding eines Formulars

[[binding-model-object]]
.Binding mit `@ModelObject`
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonSectionPmo.java[tags=personPmo-class]
----
TIP: die Definition von `modelAttribute` ist optional, wenn der Property Name im `ModelObject` und der Name der annotierten Methode gleich sind.

[[abschnitt-binding-table]]
==== Binding einer Tabelle

Um eine Section mit einer Tabelle zu erzeugen muss die annotierte Klasse <<ui-container-pmo, `org.linkki.core.ui.table.ContainerPmo<T>`>> implementieren. Der `Generic`-Parameter `T` repräsentiert den Typ des PMOs um eine Zeile in dieser Tabelle zu erzeugen.

[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonTablePmo.java[tags=personTablePmo-class]
----

Die Methode `getItems()` gibt die Zeilen der Tabelle in Form der vorher mit `T` spezifizierten 'Row PMOs' zurück.

[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonTablePmo.java[tags=personTablePmo-getItems]
----

Im `interface ContainerPmo<T>` werden noch weitere `default` Methoden spezifiziert. Eine genaue Beschreibung befindet sich <<ui-container-pmo, hier>>.

Das sogenannte 'Row PMO' ist grundsätzliche ein gewöhnliches PMO wie in <<abschnitt-form-binding, Abschnitt 1>> beschrieben. Die einzige Besonderheit ist, dass die UI-Elemente ebenfalls mit der Annotation <<ui-table-column, `@UITableColumn`>> gekennzeichnet sind.


[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonRowPmo.java[tags=personRowPmo-labelBinding]
----

Es können alle UI-Elemente ebenfalls in Tabellen verwendet werden. Ein Binding eines `@UIButton` sieht folgendermaßen aus:

[source,java]
----
include::{source-dir}/org/linkki/samples/binding/pmo/PersonRowPmo.java[tags=personRowPmo-buttonBinding]
----

NOTE: In unserem Beispiel sollen die Elemente in der Tabelle 'read-only' dargestellt werden. Deswegen erfolgt kein direktes Binding des `ModelObject` über eine mit `@ModelObject` annotierte Methode.

[[manual-binding]]
=== Manuelles Binding mit `@Bind`

Auf Grund spezieller Anforderungen oder spezieller eigener `Fields` ist es manchmal nicht möglich den <<pmo-uisection, automatischen Aufbau über `@UISection`>> zu nutzen. Für diesen Fall besteht die Möglichkeit, dass *linkki* 'nur' das Data-Binding übernimmt. Man behält somit die volle Kontrolle über die Erstellung, Anordnung und Konfiguration (z.B. `setNullRepresentation()` oder `setConverter()`) der Komponenten.

Für die Aktivierung des manuellen Bindings muss die Annotation `@Bind` auf die Komponente geschrieben werden. Es können sowohl Felder als auch Methoden annotiert werden. Unterstützte Typen sind:

* `com.vaadin.ui.Field`
* `com.vaadin.ui.Label`
* `com.vaadin.ui.Button`

Danach kann das Data-Binding über den <<missing-link, `Binder`>> erstellt werden.


.@Bind auf Felder
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/components/AddressFields.java[tags=addressFields-class]
----

.@Bind auf Methoden
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/components/AddressFields2.java[tags=addressFields-methodBinding]
----

TIP: wenn das Data-Binding von Vaadin-Komponenten einer verwendeten Library von *linkki* übernommen werden soll, kann dies durch Vererbung oder 'delegete proxies' und `@Bind` auf den Methoden aktiviert werden.

.Binding aktivieren
[source,java]
----
include::{source-dir}/org/linkki/samples/binding/components/ContactComponent.java[tags=manual-binding]
----

<<missing-link, Hier>> ist ein Beispielprojekt mit den verschiedenen Binding-Möglichkeiten.

[TIP]
====
Binding-Zusammenfassung:

* `@UISection` -> einfaches, schnelles Template mit eingeschränkten Konfigurationsmöglichkeiten
* manuelles Binding -> volle Kontrolle

*linkki* arbeitet mit bestimmten <<missing-link, Namenskonventionen>>. Dadurch verringern sich die Fehlerquellen und der refactoring Aufwand.

Die in den Annotationen verwendeten Werte für `pmoProperty` bzw. `modelAttribute` sollten in Konstanten der jeweiligen Klasse ausgelagert werden.
====
