:jbake-title: Daten auf mehreren Ebenen
:jbake-type: section
:jbake-status: published

:images-folder-name: 03_architektur
:source-dir: ../../../java

[[domain-model-binding]]
=== Daten auf mehreren Ebenen (Domain Model Binding)

Domain Model Binding, oder kurz "Model Binding", ist ein *linkki* Feature zur Vermeidung unnötigen Codes in PMO Klassen. Es zielt auf den "einfachen" Fall bei der Anbindung von UIs ab, in dem Eigenschaften aus dem Domain Model unverändert an der Oberfläche angezeigt werden. Unverändert bedeutet, dass das PMO keine Umformattierung oder andere Konvertierungen durchführen muss, bevor Werte in der UI angezeigt werden können. 

Um dieses Feature nutzen zu können, muss das UI mittels <<pmo-uisection,`@UISection`>> erstellt werden. Die Getter-Methode für das Modellobjekt im PMO muss dann mit der Annotation `@ModelObject` markiert werden.

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonSectionPmo.java[tags=modelobject]
----

Beispielsweise kann der Vorname aus dem Modell ohne Modifizierung direkt für die Anzeige verwendet werden:

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonSectionPmo.java[tags=pojo-binding]
----

In diesem Fall stellt die Getter-Methode eine direkte Delegation an ein Modellattribut dar. Daher kann das gleiche Verhalten unter Verwendung des Model Bindings erzielt werden:

[source,java]
----
include::{source-dir}/org/linkki/doc/PersonSectionPmo.java[tags=model-binding]
----
Model Binding vermeidet unnötigen Delegations-Code und ist damit eine Art "Abkürzung".

.Model Binding
image::{images}{images-folder-name}/ModelBinding.png[]

[[modell-attribut-namen]]
==== Name des Modell-Attributs

Um das Model Binding Feature verwenden zu können, muss in der <<ui-element,UI Annotation>> die Eigenschaft `modelAttribute` angegeben werden. Der Datentyp der Eigenschaft ist `String` . Der Wert von `modelAttribute` gibt an, wie die entsprechende Property in der Domain Model Klasse heißt. Existiert keine entsprechende Eigenschaft an der Domain Model Klasse, so wird bei der Erstellung der Oberfläche eine Exception geworfen.

Sobald `modelAttribute` angegeben wird, ignoriert *linkki* sowohl den Rückgabewert als auch den Inhalt der Methode im PMO. Daher kann als Rückgabetyp `void` angegeben, und der Methodenrumpf leer gelassen werden. Von nun an wird vom Data Binding nicht mehr die Methode im PMO aufgerufen, sondern immer direkt die entsprechende Methode im Domain Model.

Im obigen Beispiel heißt die Methode im `PersonPMO` `vorname()`. Im Domain Model dagegen heißt sie `firstname` bzw. `getFirstname()`. Es ist also möglich, Properties in PMO und Domain Model unterschiedlich zu benennen.

TIP: *linkki* sucht im Modell nach allen benötigten Methoden. Falls die Setter-Methode ignoriert werden soll, muss auf die Benutzung der Abkürzung verzichten werden. Hingegen kann auch bei annotierten Getter-Methoden ein Modellattribut angegeben werden. Dadurch wird im Modell nach allen Methoden gesucht, die *linkki* im PMO nicht finden kann.

Zu Beachten ist dabei, dass die Benennung der Methode nicht ohne Auswirkung ist. Wenn `modelAttribute` bei der Annotation angegeben ist, wird der ganze Methodenname als ein PMO Property behandelt. Der Name des Properties wird verwendet um <<ui-properties,UI Eigenschaften>> wie <<enabled, Editierbarkeit>>, <<visible, Sichtbarkeit>> oder <<available-values,auswählbare Werte>> zu binden.

==== Mehrere Modellobjekte

Model Binding kann auch dann zum Einsatz kommen, wenn ein PMO mehrere Modellobjekte verwendet. In diesem Fall kann in der UI Annotation die Eigenschaft `modelObject` angegeben werden. Der Datentyp der Eigenschaft ist ebenfalls String. Der Wert von `modelObject` gibt an, welches Model Object des PMOs für Model Binding verwendet werden soll. Als Identifikator von Modellobjekten wird der in der `@ModelObject` Annotation angegebene Name verwendet.

[source,java]
----
include::{source-dir}/org/linkki/doc/ContractSectionPmo.java[tags=class]
----

Im obigen Beispiel definiert die Annotation von `vornameVersichertePerson()`, dass die Property `firstname` an Modellobjekt `VP` aufgerufen werden soll. Um einen Wert zur Darstellung in der Oberfläche zu ermitteln, geht das Databinding folgendermaßen vor:

* Aufrufen der Methode `getInsuredPerson()` am PMO, da diese Methode mit `@ModelObject("VP")` annotiert ist
* Speichern des zurückgegebenen Person-Objekts
* Aufrufen des Getters für `firstname` am ermittelten Person-Objekt

Wird in der Annotation keine Eigenschaft `modelObject` angegeben, so wird die Methode aufgerufen, die mit `@ModelObject` (ohne weiteren Namen) annotiert wurde. Dementsprechend wird für `vornameVersicherungsnehmer()` das Modellobjekt über `getPolicyHolder()` ermittelt.

Sollte es Zustände geben, in denen eine mit `@ModelObject` annotierte Methode `null` zurück gibt, müssen weiterhin Getter-Methoden implementiert werden. Diese Getter-Methoden müssen an das vorhandene Modellobject delegieren und gegebenenfalls Defaultwerte liefern, wenn das Modellobjekt nicht vorhanden ist. Die Setter-Methoden müssen nicht explizit implementiert werden. Die Felder werden als Read Only behandelt, solange kein Modellobjekt vorhanden ist. Sobald ein Modellobjekt verfügbar ist, wird die Setter-Methode des Modellobjekts automatisch aufgerufen.