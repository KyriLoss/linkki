var tipuesearch = {"pages": [{"title": "Grundaufbau Binding Context", "text": " Binding, BindingContext, BindingManager  F\u00FCr jede UI-Komponente, die an einem PMO gebunden wird, erstellt linkki ein sogenanntes Binding. Bei \u00C4nderungen im PMO wird \u00FCber die Methoden des Bindings sichergestellt, dass die UI-Komponente korrekt aktualisiert wird.   Alle Bindings in linkki sind Teil eines BindingContext. \u00DCblicherweise verbindet ein BindingContext alle Bindings auf einer Seite oder in einem thematisch unabh\u00E4ngigen Abschnitt. Bei \u00C4nderungen an einem gebundenen Objekt (PMO oder UI) werden alle Bindings im gleichen Kontext aktualisiert. Mehrere PMOs k\u00F6nnen mit dem gleichen BindingContext gebunden werden.      Figure 1. BindingContext und ~Manager   Um einen oder mehrere BindingContext zu erstellen und zu verwalten, gibt es einen BindingManager. Dieser gibt zu einem Namen (ggf. abgeleitet von einer Klasse) einen BindingContext zur\u00FCck, oder erstellt bei Bedarf einen neuen. In Ableitungen von BindingManager kann festgelegt werden, welches Verhalten die vom jeweiligen BindingContext erstellten Bindings haben sollen (siehe Vertikales Binding). Soll kein besonderes Verhalten implementiert werden gen\u00FCgt ein DefaultBindingManager. Ein BindingManager wird \u00FCblicherweise @ViewScoped angelegt und jeder Page (siehe Page) \u00FCbergeben.   Ein besonderer BindingManager ist der DialogBindingManager, der daf\u00FCr sorgt, dass bei jeder \u00C4nderung auch die Validierungsmethode des Dialogs aufgerufen wird.  ", "tags": "", "url": "../03_architektur/01_grundaufbau_bindingcontext_bindingmanager.html"},{"title": "Data Binding mit PMOs", "text": " Data Binding mit PMOs  Ein Presentation Model Object kapselt den Zustand des UIs unabh\u00E4ngig von der konkreten UI-Implementierung. Das UI interagiert \u00FCber Data Binding ausschlie\u00DFlich mit diesem PMO. Dazu muss das PMO nicht alle Daten selber halten, sondern kann direkt an ein oder mehrere bestehende Modellobjekte deligieren (siehe Daten auf mehreren Ebenen). Diese Daten werden dann in ein f\u00FCr die Anzeige geeignetes Format konvertiert.   In linkki sind PMOs Plain Old Java Objects (POJOs), in der Daten f\u00FCr einzelne UI Abschnitte organisiert sind. Zu jedem Abschnitt des UIs soll es also ein eigenes PMO geben.   Ausschlaggebend f\u00FCr das Data Binding sind sogenannte Properties eines PMOs. Eine PMO Klasse besitzt ein Property names property genau dann, wenn diese Klasse eine Methode getProperty  hat. Falls der Wert dieses Propertys modifizierbar sein soll, muss es zus\u00E4tzlich eine Methode setProperty geben. Oft wird der Wert des Propertys in eine Klassenvariable property gespeichert. Dies ist an die Namenkonventionen f\u00FCr JavaBean Properties angelehnt. Die PMO Klassen m\u00FCssen allerdings selbst keine JavaBeans sein.   Betrachte zum Beispiel die folgende Klasse:    public class BeispielPmo {      private String nachname;     private String anrede;      public void setNachname(String nachname) {         this.nachname = nachname;     }      public String getAnrede() {         return anrede;     }      public void setAnrede(String anrede) {         this.anrede = anrede;     }      public String getNamensanzeige() {         return String.join( , anrede, nachname);     } }    Diese Klasse hat zwei Properties: anrede und namensanzeige. Am Property namesanzeige sieht man, dass es zu einem PMO Property nicht zwingend eine Klassenvariable geben muss. Hingegen ist nachname kein Property der Klasse, obwohl es dazu eine Klassenvariable und eine passende Setter-Methode gibt, denn es fehlt die notwendige Methode String getNachname().   Es gibt einige Interfaces, die PMO Klassen optional implementieren k\u00F6nnen:     org.linkki.core.PresentationModelObject bietet eine Methode, mit der ein Button-PMO erstellt werden kann; der daraus erzeugte Button l\u00F6st eine Bearbeitung des PMOs aus   org.linkki.core.ButtonPmo ist ein PMO f\u00FCr Buttons, siehe Buttons   org.linkki.core.ui.table.ContainerPmo ist ein PMO f\u00FCr Tabellen - die einzelnen Zeilen haben wieder regul\u00E4re PMOs, siehe auch Container Komponenten    ", "tags": "", "url": "../03_architektur/02_data_binding_mit_pmos.html"},{"title": "Daten auf mehreren Ebenen", "text": " Daten auf mehreren Ebenen (Domain Model Binding)  Domain Model Binding, oder kurz Model Binding, ist ein linkki Feature zur Vermeidung unn\u00F6tigen Codes in PMO Klassen. Es zielt auf den einfachen Fall bei der Anbindung von UIs ab, in dem Eigenschaften aus dem Domain Model unver\u00E4ndert an der Oberfl\u00E4che angezeigt werden. Unver\u00E4ndert bedeutet, dass das PMO keine Umformattierung oder andere Konvertierungen durchf\u00FChren muss, bevor Werte in der UI angezeigt werden k\u00F6nnen.   Um dieses Feature nutzen zu k\u00F6nnen, muss das UI mittels @UISection erstellt werden. Die Getter-Methode f\u00FCr das Modellobjekt im PMO muss dann mit der Annotation @ModelObject markiert werden.        @ModelObject     public Person getPerson() {         return person;     }    Beispielsweise kann der Vorname aus dem Modell ohne Modifizierung direkt f\u00FCr die Anzeige verwendet werden:        @UITextField(position = 10, label = Vorname)     public String getVorname() {         return getPerson().getFirstname();     }    In diesem Fall stellt die Getter-Methode eine direkte Delegation an ein Modellattribut dar. Daher kann das gleiche Verhalten unter Verwendung des Model Bindings erzielt werden:        @UITextField(position = 10, label = Vorname, modelAttribute = firstname)     public void vorname() {      }    Model Binding vermeidet unn\u00F6tigen Delegations-Code und ist damit eine Art Abk\u00FCrzung.      Figure 1. Model Binding   Name des Modell-Attributs  Um das Model Binding Feature verwenden zu k\u00F6nnen, muss in der UI Annotation die Eigenschaft modelAttribute angegeben werden. Der Datentyp der Eigenschaft ist String . Der Wert von modelAttribute gibt an, wie die entsprechende Property in der Domain Model Klasse hei\u00DFt. Existiert keine entsprechende Eigenschaft an der Domain Model Klasse, so wird bei der Erstellung der Oberfl\u00E4che eine Exception geworfen.   Sobald modelAttribute angegeben wird, ignoriert linkki sowohl den R\u00FCckgabewert als auch den Inhalt der Methode im PMO. Daher kann als R\u00FCckgabetyp void angegeben, und der Methodenrumpf leer gelassen werden. Von nun an wird vom Data Binding nicht mehr die Methode im PMO aufgerufen, sondern immer direkt die entsprechende Methode im Domain Model.   Im obigen Beispiel hei\u00DFt die Methode im PersonPMO vorname(). Im Domain Model dagegen hei\u00DFt sie firstname bzw. getFirstname(). Es ist also m\u00F6glich, Properties in PMO und Domain Model unterschiedlich zu benennen.      Tip   linkki sucht im Modell nach allen ben\u00F6tigten Methoden. Falls die Setter-Methode ignoriert werden soll, muss auf die Benutzung der Abk\u00FCrzung verzichten werden. Hingegen kann auch bei annotierten Getter-Methoden ein Modellattribut angegeben werden. Dadurch wird im Modell nach allen Methoden gesucht, die linkki im PMO nicht finden kann.      Zu Beachten ist dabei, dass die Benennung der Methode nicht ohne Auswirkung ist. Wenn modelAttribute bei der Annotation angegeben ist, wird der ganze Methodenname als ein PMO Property behandelt. Der Name des Properties wird verwendet um UI Eigenschaften wie Editierbarkeit, Sichtbarkeit oder ausw\u00E4hlbare Werte zu binden.    Mehrere Modellobjekte  Model Binding kann auch dann zum Einsatz kommen, wenn ein PMO mehrere Modellobjekte verwendet. In diesem Fall kann in der UI Annotation die Eigenschaft modelObject angegeben werden. Der Datentyp der Eigenschaft ist ebenfalls String. Der Wert von modelObject gibt an, welches Model Object des PMOs f\u00FCr Model Binding verwendet werden soll. Als Identifikator von Modellobjekten wird der in der @ModelObject Annotation angegebene Name verwendet.    @UISection public class ContractSectionPmo {      private final Contract contract;       public ContractSectionPmo(Contract contract) {         this.contract = contract;     }       @ModelObject     public Person getPolicyHolder() {         return contract.getPolicyHolder();     }      @ModelObject(name = VP)     public Person getInsuredPerson() {         return contract.getInsuredPerson();     }       @UITextField(position = 10, label = Vorname VN, modelAttribute = firstname)     public void vornameVersicherungsnehmer() {     }      @UITextField(position = 20, label = Vorname VP, modelAttribute = firstname, modelObject = VP)     public void vornameVersichertePerson() {     }  }    Im obigen Beispiel definiert die Annotation von vornameVersichertePerson(), dass die Property firstname an Modellobjekt VP aufgerufen werden soll. Um einen Wert zur Darstellung in der Oberfl\u00E4che zu ermitteln, geht das Databinding folgenderma\u00DFen vor:     Aufrufen der Methode getInsuredPerson() am PMO, da diese Methode mit @ModelObject(VP) annotiert ist   Speichern des zur\u00FCckgegebenen Person-Objekts   Aufrufen des Getters f\u00FCr firstname am ermittelten Person-Objekt     Wird in der Annotation keine Eigenschaft modelObject angegeben, so wird die Methode aufgerufen, die mit @ModelObject (ohne weiteren Namen) annotiert wurde. Dementsprechend wird f\u00FCr vornameVersicherungsnehmer() das Modellobjekt \u00FCber getPolicyHolder() ermittelt.   ", "tags": "", "url": "../03_architektur/03_daten_auf_mehreren_ebenen.html"},{"title": "Binding weiterer UI-Eigenschaften", "text": " Binding von weiteren UI-Element-Eigenschaften  Neben dem anzuzeigenden Wert k\u00F6nnen weitere Eigenschaften der UI-Elemente per Databinding an Methoden des PMO gebunden werden. Die genaue Funktionsweise wird im Kapitel UI-Komponenten n\u00E4her beschrieben.  ", "tags": "", "url": "../03_architektur/04_binding_von_weiteren_ui-element-eigenschaften.html"},{"title": "Querschnittsaspekte im Databinding", "text": " Querschnittsaspekte im Databinding  Zum Gro\u00DFteil bestimmen Informationen aus PMOs und Domain Model den Zustand der UI. In vielen Anwendungen jedoch muss die Oberfl\u00E4che zus\u00E4tzlich durch andere Informationen, z.B. den Systemzustand beeinflusst werden. Diese Informationen nennen wir im Folgenden Querschnittsaspekte.   Das Standardbeispiel f\u00FCr einen Querschnittsaspekt ist der Browse Mode. Viele Anwendungen unterscheiden zwischen:     Editiermodus (Edit Mode), in dem Informationen in der Oberfl\u00E4che eingegeben und ver\u00E4ndert werden k\u00F6nnen   Ansichtsmodus (Browse Mode), in dem Daten in Formularen zwar angezeigt werden, aber schreibgesch\u00FCtzt sind     H\u00E4ufig wechseln Anwendungen zwischen diesen Modi hin und her, z.B. indem eine \u00C4nderung begonnen oder abgeschlossen wird. Im Browse Mode gilt, dass alle Felder in Formularen schreibgesch\u00FCtzt sind. Dieser globale Bearbeitungszustand der Anwendung beeinflusst also viele Felder gleichzeitig. Zus\u00E4tzlich \u00FCberstimmt der Browse Mode die Einstellungen aus PMOs. Selbst wenn ein PMO ein Feld als editierbar angibt, ist es im Browse Mode schreibgesch\u00FCtzt.   Auf technischer Ebene existieren zwei linkki-Konstrukte, um Querschnittsaspekte abzubilden: PropertyDispatcher und PropertyBehaviors.   PropertyDispatcher  Der BindingContext (siehe Grundaufbau BindingContext - BindingManager) verwendet eine PropertyDispatcherFactory, die mehrere miteinander verkn\u00FCpfte PropertyDispatcher erstellt. Diese Dispatcher wiederum werden zum Binden der Properties und ihrer Eigenschaften (siehe Binding von weiteren UI-Element-Eigenschaften) verwendet. PropertyDispatcher haben Methoden zur Abfrage von Datentyp und Wert einer Property, sowie der zugeh\u00F6rigen Eigenschaften. Standardm\u00E4\u00DFig werden in linkki vier miteinander verkn\u00FCpfte Dispatcher erstellt, die jeweils an den N\u00E4chsten delegieren, wenn sie selbst den Wert nicht liefern k\u00F6nnen:     BehaviorDependentDispatcher verwendet PropertyBehaviors (siehe im n\u00E4chsten Abschnitt, PropertyBehaviors)   BindingAnnotationDispatcher liefert Informationen die aus den UI-Annotationen direkt abgelesen werden k\u00F6nnen   ReflectionPropertyDispatcher greift per Reflection auf die aus dem Propertynamen abgeleiteten Methoden am PMO bzw. Domain Model zu   ExceptionPropertyDispatcher wirft eine Exception, falls die entsprechende Eigenschaft nicht verf\u00FCgbar ist - dies deutet h\u00E4ufig auf einen Tippfehler in einem Methodennamen hin, aufgrunddessen der ReflectionPropertyDispatcher die passende Methode nicht finden kann        Figure 1. Beispiel f\u00FCr PropertyDispatcher   Eigene Dispatcher k\u00F6nnen \u00FCber eine eigene PropertyDispatcherFactory (in einem eigenen BindingContext) erstellt werden. Dort muss die Methode createCustomDispatchers \u00FCberschrieben werden, um einen oder mehrere eigene Dispatcher bereitzustellen. Diese anwendungsspezifischen Dispatcher werden zwischen BehaviorDependentDispatcher und BindingAnnotationDispatcher eingeh\u00E4ngt.    PropertyBehaviors  PropertyBehaviors werden von einem PropertyBehaviorProvider erstellt, der dem BindingContext als Konstruktor-Parameter \u00FCbergeben werden kann. Welche PropertyBehaviors verwendet werden, kann also von der Anwendung konfiguriert werden.   \u00DCber PropertyBehaviors kann ein BehaviorDependentDispatcher das Verhalten von Eigenschaften steuern. Nur eine Auswahl der Eigenschaften sind dar\u00FCber steuerbar: Sichtbarkeit (isVisible), Editierbarkeit (isWritable) und Anzeige von Fehlern (isShowValidationMessages). Dazu werden alle PropertyBehaviors aufgerufen; geben sie einstimmig true zur\u00FCck, leitet der BehaviorDependentDispatcher die Anfrage an den n\u00E4chsten PropertyDispatcher weiter, ansonsten gibt er direkt false bzw. eine leere Fehlerliste zur\u00FCck, oder setzt den Wert nicht.      Figure 2. Veto eines PropertyBehaviors   F\u00FCr eigene Verhaltensweisen kann das Interface PropertyBehavior implementiert werden. So kann zum Beispiel eine komplette Seite in einen Lese- oder Schreibmodus versetzt werden:    class ReadOnlyBehavior implements PropertyBehavior {      private boolean editable;      public ReadOnlyBehavior(boolean editable) {        this.editable = editable;     }      @Override     public boolean isWritable(Object boundObject, String property) {         return editable;     } }    ", "tags": "", "url": "../03_architektur/05_querschnittsaspekte_im_databinding.html"},{"title": "Section", "text": " Section  Eine Gruppe von Eingabefeldern oder eine Tabelle wird als Section bezeichnet. Eine Section kann einen Titel haben und wird in diesem Fall auch optisch durch eine Linie in der Titelleiste abgegrenzt. Wenn eine Section keinen Titel hat, ist sie optisch im flie\u00DFenden Layout nicht direkt zu erkennen.   Eine Section legt au\u00DFderdem fest, in welcher Anordnung der Inhalt dargestellt werden soll: horizontal oder vertikal. Im horizontalen Layout werden alle Eingabefelder in einer Zeile, nebeneinander dargestellt. Im vertikalen Layout werden die Felder untereinander dargetstellt. Wenn zus\u00E4tzlich eine Anzahl von Spalten durch die Eigenschaft columns festgelegt wird, wird zeilenweise (links-rechts) eine Art Grid Layout aufgebaut.   Die Section kann anstatt mehrere Eingabefelder auch eine Tabelle enthalten und wird dann als TableSection genannt.   SectionID  Auf jedes HTML Element einer Section kann per ID zugegriffen werden. Dies kann beispielsweise benutzt werden, um eine Section f\u00FCr UI-testing zu identifizieren. Standardm\u00E4\u00DFig wird die ID mit dem SimpleName der Klasse vorbelegt. Alternativ kann mit der Annotation '@SectionID' eine Methode markiert werden, welche die ID der Section zur\u00FCckgibt.   Eine Section, die mit '@SectionID' markiert ist, ruft die hinterlegte Methode genau einmal auf. Diese bleibt f\u00FCr die Sitzung unver\u00E4ndert und wird auch nicht dynamisch aktualisiert.   ", "tags": "", "url": "../04_erstellung_eines_ui/01_section.html"},{"title": "PMO mit UI Section", "text": " PresentationModelObject mit @UISection  Wird eine Klasse mit @UISection annotiert, \u00FCbernimmt linkki die Kontrolle \u00FCber die Erstellung und Anordnung der definierten Komponenten. \u00DCber die Annotation f\u00FCr die zugeh\u00F6rigen UI-Elemente k\u00F6nnen bestimmte Aspekte definiert und/oder gesteuert werden. Die Sections werden \u00FCber SectionFactories erstellt.   Die UI-Elemente werden entweder an die 'properties' eines ModelObjects oder eines PMO#8217;s gebunden. Eine detaillierte Beschreibung gibt es im Kapitel Daten auf mehreren Ebenen.      Tip   In allen F\u00E4llen gilt: existiert im ModelObject oder PMO kein 'Setter', dann ist das Feld readOnly      Im ersten Abschnitt wird beispielhaft die Erstellung einer Section eines 'standard' Formulars beschreibt. Im zweiten Abschnitt wird das erstellen einer Section mit einer Tabelle erleutert.   Binding eines Formulars  Binding mit @ModelObject  @UISection public class PersonSectionPmo implements PresentationModelObject {      @ModelObject     public Person getPerson() {         return person;     }      @UITextField(position = 10, label = Firstname, required = RequiredType.REQUIRED, modelAttribute = firstname)     public void firstname() {         /* model binding only */ }      @UITextField(position = 20, label = Lastname, required = RequiredType.REQUIRED, modelAttribute = lastname)     public void lastname() {         /* model binding only */ }      @UIComboBox(position = 30, label = Gender, content = AvailableValuesType.ENUM_VALUES_EXCL_NULL, itemCaptionProvider = ToStringCaptionProvider.class)     public void gender() {         /* model binding only */ }  }       Tip   die Definition von modelAttribute ist optional, wenn der Property Name im ModelObject und der Name der annotierten Methode gleich sind.       Binding einer Tabelle  Um eine Section mit einer Tabelle zu erzeugen muss die annotierte Klasse org.linkki.core.ui.table.ContainerPmolt;Tgt; implementieren. Der Generic-Parameter T repr\u00E4sentiert den Typ des PMOs um eine Zeile in dieser Tabelle zu erzeugen.    @UISection public class PersonTablePmo implements ContainerPmolt;PersonRowPmogt; {    Die Methode getItems() gibt die Zeilen der Tabelle in Form der vorher mit T spezifizierten 'Row PMOs' zur\u00FCck.        @Override     public Listlt;PersonRowPmogt; getItems() {         return items.get();     }    Im interface ContainerPmolt;Tgt; werden noch weitere default Methoden spezifiziert. Eine genaue Beschreibung befindet sich hier.   Das sogenannte 'Row PMO' ist grunds\u00E4tzliche ein gew\u00F6hnliches PMO wie in Abschnitt 1 beschrieben. Die einzige Besonderheit ist, dass die UI-Elemente ebenfalls mit der Annotation @UITableColumn gekennzeichnet sind.        @UITableColumn(expandRatio = 0.25F)     @UILabel(position = 10, label = Name)     public String getName() {         return person.getName();     }    Es k\u00F6nnen alle UI-Elemente ebenfalls in Tabellen verwendet werden. Ein Binding eines @UIButton sieht folgenderma\u00DFen aus:        @UITableColumn(expandRatio = 0.1F)     @UIToolTip(text = Edit)     @UIButton(position = 30, icon = FontAwesome.EDIT, showIcon = true)     public void edit() {         editAction.accept(person);     }       Note   In unserem Beispiel sollen die Elemente in der Tabelle 'read-only' dargestellt werden. Deswegen erfolgt kein direktes Binding des ModelObject \u00FCber eine mit @ModelObject annotierte Methode.      ", "tags": "", "url": "../04_erstellung_eines_ui/02_presentationmodelobject_mit_uisection.html"},{"title": "Manuelles Binding mit `@Bind`", "text": " Manuelles Binding mit @Bind  Auf Grund spezieller Anforderungen oder spezieller eigener Fields ist es manchmal nicht m\u00F6glich den automatischen Aufbau \u00FCber @UISection zu nutzen. F\u00FCr diesen Fall besteht die M\u00F6glichkeit, dass linkki 'nur' das Data-Binding \u00FCbernimmt. Man beh\u00E4lt somit die volle Kontrolle \u00FCber die Erstellung, Anordnung und Konfiguration (z.B. setNullRepresentation() oder setConverter()) der Komponenten.   F\u00FCr die Aktivierung des manuellen Bindings muss die Annotation @Bind auf die Komponente geschrieben werden. Es k\u00F6nnen sowohl Felder als auch Methoden annotiert werden. Unterst\u00FCtzte Typen sind:     com.vaadin.ui.Field   com.vaadin.ui.Label   com.vaadin.ui.Button     Danach kann das Data-Binding \u00FCber den Binder erstellt werden.   @Bind auf Felder  public class AddressFields {      @Bind(pmoProperty = street)     private final TextField streetTxt;      @Bind(pmoProperty = zip)     private final TextField zipTxt;      @Bind(pmoProperty = city)     private final TextField cityTxt;      @Bind(pmoProperty = country, availableValues = AvailableValuesType.DYNAMIC)     private final ComboBox countryCb;  }    @Bind auf Methoden      @Bind(pmoProperty = street)     public TextField getStreetTxt() {         return streetTxt;     }      @Bind(pmoProperty = zip)     public TextField getZipTxt() {         return zipTxt;     }      @Bind(pmoProperty = city)     public TextField getCityTxt() {         return cityTxt;     }      @Bind(pmoProperty = country, availableValues = AvailableValuesType.DYNAMIC)     public ComboBox getCountryCb() {         return countryCb;     }       Tip   wenn das Data-Binding von Vaadin-Komponenten einer verwendeten Library von linkki \u00FCbernommen werden soll, kann dies durch Vererbung oder 'delegete proxies' und @Bind auf den Methoden aktiviert werden.      Binding aktivieren          new Binder(addressFields, addressPmo).setupBindings(context);    Hier ist ein Beispielprojekt mit den verschiedenen Binding-M\u00F6glichkeiten.      Tip    Binding-Zusammenfassung:     @UISection #8594; einfaches, schnelles Template mit eingeschr\u00E4nkten Konfigurationsm\u00F6glichkeiten   manuelles Binding #8594; volle Kontrolle     linkki arbeitet mit bestimmten Namenskonventionen. Dadurch verringern sich die Fehlerquellen und der refactoring Aufwand.   Die in den Annotationen verwendeten Werte f\u00FCr pmoProperty bzw. modelAttribute sollten in Konstanten der jeweiligen Klasse ausgelagert werden.      ", "tags": "", "url": "../04_erstellung_eines_ui/03_manuelles_binding_mit_bind.html"},{"title": "UI Element", "text": " UI-Element  Felder und Buttons werden zusammengefasst UI-Element genannt. Es gibt folgende Arten:   Table 1. Felder       UILabel Anzeige von Text   UITextField Feld f\u00FCr einzeilige Texteingabe   UITextArea Bereich f\u00FCr mehrzeilige Texteingabe   UIIntegerField, UIDoubleField Eingabefeld f\u00FCr Zahlen   UICheckbox Control f\u00FCr booleanwertige Eingabe   UIDateField Feld f\u00FCr Datumeingabe mit Date Picker   UICombobox Dropdown Feld mit vorgegebenen Auswahlm\u00F6glichkeiten     Table 2. Buttons       UIButton Ein Button, der beim Klick eine Aktion ausf\u00FChrt     Der Typ eines Feldes kann dynamisch bestimmt werden. Dieser Mechanismus wird als Dynamic Field bezeichnet.   Annotationen f\u00FCr sowohl Felder als auch Buttons m\u00FCssen an Methoden in einer PMO Klasse stehen. Der Hauptunterschied zwischen Feldern und Buttons liegt darin, dass Felder zur Anzeige und zum Bearbeiten von Werten dienen, und somit per Data Binding an einen Wert gebunden werden. Deshalb m\u00FCssen die Annotationen f\u00FCr Felder an einer Getter-Methode eines PMO Propertys stehen. Nur wenn Domain Model Binding benutzt wird, kann die Methode abweichend benannt werden.   Buttons hingegen werden nicht an einen Wert gebunden, sondern an die annotierte Methode. Sie stellt eine ausf\u00FChrbare Aktion dar, die beim Mausklick aufgerufen wird.   Eigenschaften  Alle UI-Elemente haben folgende Eigenschaften gemeinsam:     position: int   label: String   noLabel: boolean/showLabel: boolean   enabled: boolean (nicht bei allem Elementen konfigurierbar)   visible: boolean   required: boolean (nicht bei allem Elementen konfigurierbar)     Felder haben zus\u00E4tzliche Eigenschaften, die f\u00FCr das Domain Model Binding ben\u00F6tigt werden:     modelObject: String   modelAttribute: String        Caution   position muss zwingend angegeben werden. F\u00FCr alle anderen Eigenschaft sind Default-Werte konfiguriert.      Position  Die Eigenschaft position bestimmt die Reihenfolge der Elemente im UI. Wichtig dabei ist nur die relative Gr\u00F6\u00DFe der Zahl. Elemente mit der kleineren position werden zuerst der Section hinzugef\u00FCgt.      Tip   L\u00FCcken sind erlaubt und \u00FCblich, damit bei einem sp\u00E4teren Einf\u00FCgen eines neuen UI-Elements nicht alle Positionen neu vergeben werden m\u00FCssen.       Label  \u00DCblicherweise gibt es zu einem UI-Element einen beistehenden Label-Text, der das Element beschreibt. Der Inhalt des Labels wird \u00FCber dieses Attribut festgelegt.   Soll kein Label (im Unterschied zu einem leeren) angezeigt werden, kann dies \u00FCber noLabel = true gesteuert werden.   Ausnahme ist hier der Button, bei dem normalerweise kein Label angezeigt wird. Daher hei\u00DF dort die Eigenschaft showLabel und ist mit dem Wert false vorbelegt. Das Anzeigen des Labels muss mit showLabel = true erzwungen werden.      Note   Falls ein alleinstehendes Label ben\u00F6tigt wird, soll das UI-Element UILabel benutzt werden.       Enabled  Die Eigenschaft enabled steuert, ob die Komponente aktiv/editierbar ist. Es gibt folgende Einstellungsm\u00F6glichkeiten:   Table 3. EnabledType       ENABLED der Inhalt des Elements ist im UI ver\u00E4nderbar (default)   DISABLED der Inhalt des Elements ist im UI nicht ver\u00E4nderbar   DYNAMIC ob der Inhalt ver\u00E4nderbar ist h\u00E4ngt vom R\u00FCckgabewert der Methode boolean islt;PropertyNamegt;Enabled() ab        Note   Ein UILabel bietet diese Option nicht und ist immer ENABLED.       Visible  Die Eigenschaft visible gibt an, ob die Komponente sichtbar ist. Folgende M\u00F6glichkeiten stehen zur Verf\u00FCgung:   Table 4. VisibleType       VISIBLE das UI-Element ist sichtbar (default)   INVISIBLE das UI-Element ist unsichtbar   DYNAMIC ob das UI-Element sichtbar ist, h\u00E4ngt vom R\u00FCckgabewert der Methode boolean islt;PropertyNamegt;Visible() ab      Required  Die Eigenschaft required markiert optisch Pflichtfelder. Konfigurierbare Optionen sind:   Table 5. RequiredType       REQUIRED das UI-Element ist ein Pflichtfeld (ein Wert muss eingegeben/ausgew\u00E4hlt werden)   REQUIRED_IF_ENABLED das UI-Element ist ein Pflichtfeld falls es enabled ist   NOT_REQUIRED das UI-Element ist ein optionales Feld (default)   DYNAMIC ob das Feld ein Pflichtfeld ist, h\u00E4ngt vom R\u00FCckgabewert der Methode boolean islt;PropertyNamegt;Required() ab        Note   UILabels und UIButtons bieten diese Einstellung nicht und sind immer NOT_REQUIRED.         Warning   required markiert Pflichtfelder nur optisch. Es erfolgt keine Validierung.       ModelObject und -Attribute  Ein Feld kann \u00FCber Domain Model Binding an einem Attribut von einem bereits bestehenden Modell-Object gebunden werden. Hierf\u00FCr werden die Eigenschaften modelAttribute und gegebenenfalls modelObject ben\u00F6tigt. Die genaue Funktionsweise wird im Abschnitt Namen von Modell-Attribut beschrieben.     UILabel  Die Annotation @UILabel stellt ein alleinstehendes UI-Element zur Anzeige von String Inhalten dar. Im Gegensatz zu einem deaktivierten UITextField wird der Text nicht in einem Eingabefeld umrahmt. Diese Annotation entspricht einem com.vaadin.ui.Label.   Die annotierte Methode muss einen Wert von Typ String zur\u00FCckgeben. Der R\u00FCckgabewert bestimmt, was als Label angezeigt wird.      Tip   Auch ein UILabel hat zus\u00E4tzlich die Eigenschaft label. Falls dort ein Wert gesetzt ist, w\u00FCrde der Text neben dem UILabel erscheinen.      HTML-Content  Der Inhalt des Labels kann mit HTML gestaltet werden, wenn htmlContent=true angegeben wird.   Beispiel HTML-Label-Content      @UILabel(position = 1, label = , htmlContent = true)     public String getGender() {         switch (person.getGender()) {             case FEMALE:                 return FontAwesome.FEMALE.getHtml();             case MALE:                 return FontAwesome.MALE.getHtml();              default:                 return FontAwesome.GENDERLESS.getHtml();         }      }     Stile  Um Labels optisch gestalten zu k\u00F6nnen kann \u00FCber die Eigenschaft styleNames eine Liste (genau genommen: ein String[]) von CSS Klassennamen angegeben werden.     UICheckbox  Eine com.vaadin.ui.CheckBox, gebunden an eine boolesche Property.    UITextField  Ein com.vaadin.ui.TextField f\u00FCr Texteingaben. Die Annotation UITextfield hat zwei zus\u00E4tzliche Eigenschaften:     columns: int   maxLength: int     Die Eigenschaft columns bestimmt die Breite des Textfeldes. Wenn hierf\u00FCr kein positiver Wert gesetzt wird, wird der verf\u00FCgbare Platz benutzt.   maxLength bestimmt die maximale Anzahl an Zeichen, die in dem Feld eingegeben oder angezeigt werden kann.    UITextArea  Die Annotation UITextArea entspricht einer com.vaadin.ui.TextArea. Sie dient zur Eingaben/Anzeige von Texten, die \u00FCber eine Zeile hinausgehen. UITextArea hat alle Eigenschaften von der Annotation UITextfield. Dar\u00FCberhinaus hat sie die Eigenschaft     rows: int     Die Eigenschaft rows bestimmt, wie hoch die UITextArea sein soll, und nicht wie viele Zeilen eingegeben werden d\u00FCrfen. Der Defaultwert hierf\u00FCr ist 1.    UIIntegerField und UIDoubleField  @UIInterfield und @UIDoubleField sind Textfelder um Zahlen formatiert darzustellen. Wie @UITextField haben auch diese Annotationen die Eigenschaft maxLength.   Das Format kann \u00FCber die Eigenschaft format: String angegeben werden, wobei die Notation des java.text.NumberFormat verwendet wird.   Wird kein Format angegeben, nutzt linkki f\u00FCr ein UIIntegerField das Java Default Integer-NumberFormat (java.text.NumberFormat#getIntegerInstance(java.util.Locale)). F\u00FCr ein UIDoubleField wird das Format #,##0.00## benutzt. Dieses Format bedeutet, dass es mindestens eine Stelle vor und zwei nach dem Dezimaltrennzeichen angezeigt werden, mit Tausendertrennzeichen. Die Dokumentation f\u00FCr die Formatangabe kann in der Klasse java.text.DecimalFormat nachgelesen werden.    UIDateField  Die Annotation @UIDateField entspricht einem Datums-Eingabefeld  (com.vaadin.ui.DateField). Es erlaubt die Angabe eines Datumsformats \u00FCber die Eigenschaft dateFormat: String. Wird kein Datumsformat angegeben wird das zur Locale passende Format verwendet. In linkki ist f\u00FCr Deutsch dd.MM.yyyy als Standardformat eingestellt. F\u00FCr andere Sprachen wird auf  DateFormat.SHORT aus dem JDK zur\u00FCckgegriffen.      Tip   Das Property kann sowohl java.time.LocalDate als auch org.joda.time.LocalDate zur\u00FCckgeben.       UIComboBox  Eine @UIComboBox erlaubt die Auswahl eines Wertes aus einer Liste. Sie besitzt 3 weitere Eigenschaften:     content: AvailableValuesType   width: String   itemCaptionProvider: Classlt;? extends ItemCaptionProviderlt;?gt;gt;          @UIComboBox(position = 20,             label = Model,             modelAttribute = Car.PROPERTY_MODEL,             required = RequiredType.REQUIRED_IF_ENABLED,             content = AvailableValuesType.DYNAMIC,             itemCaptionProvider = ToStringCaptionProvider.class)     public void model() {         /* model binding */     }    Content  \u00DCber das Attribut content wird definiert, welche Werte zur Auswahl stehen:   Table 6. AvailableValuesType       ENUM_VALUES_INCL_NULL die Werte in der Combobox entsprechen den Werten des Enum-Datentypen der Property erg\u00E4nzt um den Wert null (default)   ENUM_VALUES_EXCL_NULL die Werte in der Combobox entsprechen den Werten des Enum-Datentypen der Property   DYNAMIC die Werte in der Combobox werden \u00FCber die Methode Collectionlt;Tgt; getlt;PropertyNamegt;AvailableValues() ermittelt   NO_VALUES In dieser Combobox sind keine Werte ausw\u00E4hlbar      Width  Mit der Eigenschaft width kann in CSS-Syntax (z.B. 25em oder 100%) die Breite der ComboBox definiert werden. Der Defaultwert ist -1px und somit die Standardgr\u00F6\u00DFe, die Vaadin vorgibt.    ItemCaptionProvider  F\u00FCr die Darstellung der einzelnen Werte in der ComboBox wird der org.linkki.core.ui.components.ItemCaptionProviderlt;Tgt; verwendet. Per Default ist dies ein DefaultCaptionProvider, der eine Methode getName() erwartet. \u00DCber die Eigenschaft itemCaptionProvider kann eine andere Implementierungsklasse angegeben werden. linkki bringt dazu noch zwei weitere mit:     ToStringCaptionProvider: verwendet die toString()-Methode der Elemente   IdAndNameCaptionProvider: zeigt Name und ID zusammen im Format name [ID] an aus den Methoden getName() und getId()       UISubsetChooser  F\u00FCr die Auswahl mehrerer Werte aus einer Liste bietet linkki den @UISubsetChooser. In diesem UI Control werden Elemente aus der linken Liste in die rechte Liste verschoben um sie auszuw\u00E4hlen. Die Darstellung der einzelenen Werte erfolgt wie bei der UIComboBox, wobei der Default in diesem Fall ToStringCaptionProvider ist. Wie bei UICombobox kann man auch hier die Breite \u00FCber die Eigenschaft width einstellen.   Der Inhalt eines SubsetChoosers muss \u00FCber die Methode Collectionlt;Tgt; getlt;PropertyNamegt;AvailableValues() angegeben werden. Die gebundene Property muss vom Typ Setlt;Tgt; sein.   Die Bezeichungen der beiden Spalten k\u00F6nnen \u00FCber die Eigenschaften leftColumnCaption: String und rightColumnCaption: String angegeben werden.    UICustomField  Auch andere Controls k\u00F6nnen ohne Aufwand von linkki erzeugt und gebunden werden. Dazu stellt linkki die Annotation @UICustomField zur Verf\u00FCgung.   Mit der Eigenschaft uiControl: Classlt;? extends Fieldlt;?gt;gt; wird die Control-Klasse angegeben. Erbt das Control von com.vaadin.ui.AbstractSelect, so k\u00F6nnen wie bei der UIComboBox \u00FCber content: AvailableValuesType die verf\u00FCgbare Werte angegeben werden.      Warning   @UICustomField unterst\u00FCtzt nur Controls, die \u00FCber einen parameterlosen Konstruktor verf\u00FCgen.      UICustomField Beispiel: PasswordField      @UICustomField(position = 20, label = Password, required = RequiredType.REQUIRED, modelAttribute = User.PROPERTY_PASSWORD, uiControl = PasswordField.class)     public void password() {         // model binding     }     Dynamic Field  linkki bietet die M\u00F6glichkeit dynamisch den Typ des Eingabefelds zu bestimmen. Im folgenden Beispiel soll der Selbstbehalt nur beim Autotyp STANDARD frei eingetragen werden d\u00FCrfen. Andernfalls muss der User einen Wert aus einer vorgegebenen Liste w\u00E4hlen:        @UIDoubleField(position = 30,             label = Retention,             modelAttribute = Car.PROPERTY_RETENTION,             required = RequiredType.REQUIRED_IF_ENABLED)     @UIComboBox(position = 30,             label = Retention,             modelAttribute = Car.PROPERTY_RETENTION,             required = RequiredType.REQUIRED_IF_ENABLED,             content = AvailableValuesType.DYNAMIC,             itemCaptionProvider = RetentionCaptionProvider.class)     public void retention() {         /* model binding */     }      public Listlt;Doublegt; getRetentionAvailableValues() {         return Arrays.asList(2_000.0, 5_000.0, 10_000.0);     }      public Classlt;?gt; getRetentionComponentType() {         return car.getCarType() == CarType.STANDARD ? UIDoubleField.class : UIComboBox.class;     }    Die zur Auswahl stehenden UI-Elemente werden wie \u00FCblich als Annotation an der Methode definiert. Sie m\u00FCssen allerdings folgende Kriterien erf\u00FCllen, damit der Typ des Feldes dynamisch ermittelt werden kann:     die position in den UI*-Annotations muss \u00FCbereinstimmen   das label muss den gleichen Wert haben     Wenn die position Werte identisch sind, aber die label Werte sich unterscheiden, wird eine Exception geworfen.   Welches UI-Element f\u00FCr die jeweilige Instanz des PMO angezeigt wird, wird durch die Methode Classlt;?gt; getlt;PropertyNamegt;ComponentType() ermittelt. Diese gibt die Klasse der UI*-Annotation f\u00FCr das anzuzeigende UI-Control zur\u00FCck.    Button  Mit der Annotation @UIButton markiert man eine Methode, die beim Klick auf den Button ausgef\u00FChrt werden soll.   Buttons werden nicht an einen Wert gebunden. Da dem Button somit auch keine PMO Property zugeordnet werden kann, wird der Name der annotierten Methode zur Bestimmung von zugeh\u00F6rigen Methoden benutzt. Es verh\u00E4lt sich also \u00E4hnlich wie beim Domain Model Binding, obwohl Buttons keine Eigenschaft modelAttribute anbieten.        @UIButton(position = 10, showIcon = true, icon = FontAwesome.SAVE, captionType = CaptionType.NONE, shortcutKeyCode = KeyCode.ENTER, enabled = EnabledType.DYNAMIC)     public void save() {         saveAction.apply();     }      public boolean isSaveEnabled() {         return canSaveSupplier.getAsBoolean();     }      @UIButton(position = 20, captionType = CaptionType.STATIC, caption = reset, styleNames = BaseTheme.BUTTON_LINK)     public void reset() {         resetAction.apply();     }    Im Gegensatz zu anderen UI-Elementen bietet @UIButton nicht die Eigenschaft noLabel, sondern stattdessen showLabel. Der Defaultwert ist false. Zus\u00E4tzlich zu den gemeinsamen Eigenschaften haben Buttons weitere Eigenschaften:     caption: String   captionType: CaptionType   icon: FontAwesome   show-icon: boolean   styleNames: String[]   shortcutKeyCode: int   shortcutModifierKeys: int[]     Caption  Mit Caption wird der Text bezeichnet, der auf dem Button erscheint. Dies ist nicht zu verwechseln mit Label, das meist neben dem Control steht. Ein Button kann auch gleichzeitig einen Caption- und einen Labeltext haben.     captionType: CaptionType     Table 7. CaptionType       STATIC die Caption des Buttons wird aus dem Attribut caption entnommen (default)   NONE der Button hat keine Caption   DYNAMIC die Caption des Buttons entspricht dem R\u00FCckgabewert der Methode String getlt;PropertyNamegt;Caption(). Der Wert des Attributs caption wird ignoriert.      Icon  Zus\u00E4tzlich zur Caption kann auf Buttons ein Icon angezeigt werden. Hierf\u00FCr werden die Konstanten von der Vaadin Klasse FontAwesome benutzt. Damit ein Icon angezeigt wird, muss die Eigenschaft showIcon auf true gesetzt werden.    Style Names  Je nach Funktion m\u00FCssen Buttons oft unterschiedlich gestaltet werden. Ein g\u00E4ngiges Beispiel ist hier der Linkbutton, ein Button, der wie ein Link aussieht. Die Annotation @UIButton hat deshalb die Eigenschaft styleNames. Die Werte dieser Eigenschaft sind die CSS-Klassennamen, die f\u00FCr den Button gelten sollen.    Key Bindings  Manche Buttons sollen nicht nur durch einen Mausklick ausgel\u00F6st werden, sondern auch bei bestimmten Tastenkombinationen. Das kann mit den Eigenschaften shortcutModifierKeys und shortcutKeyCode angegeben werden. shortcutModifierKeys gibt an, welche Tasten gedr\u00FCckt gehalten sein muss, bevor die Taste mit der shortcutKeyCode gedr\u00FCckt wird. Zum Beispiel wird das Speichern in vielen Anwendungen durch die Tastenkombination Strg + s ausgel\u00F6st. Hier ist die Strg-Taste der Modifier, und die s-Taste der ShortcutKey.   Bei beiden Eigenschaften werden Tasten durch einen Integerwert repr\u00E4sentiert. Diese k\u00F6nnen in den Vaadin Klassen ModifierKey und KeyCode gefunden werden.    ", "tags": "", "url": "../05_ui_komponenten/01_ui_element.html"},{"title": "Tooltips", "text": " Tooltips  Um Tooltips an UI-Elementen anzuzeigen, stellt linkki die Annotation @UITooltip zur Verf\u00FCgung. Diese Annotation kann bei PMO-Binding an die Methode, mit der das UI-Element gebunden wird, hinzugef\u00FCgt werden. Bei Binding mittels der @Bind-Annotation muss @UITooltip direkt an das mit @Bind annotierte Feld geschrieben werden.   Die Annotation @UITooltip bietet 2 Eigenschaften an:     text: String   toolTipType: ToolTipType     Text  Dieser Text wird bei ToolTipType.STATIC angezeigt. Als Default ist hier ein Leerstring () definiert.    ToolTipType  Folgende Konfigurationsm\u00F6glchkeiten stehen f\u00FCr den ToolTipType zur Auswahl:   Table 1. ToolTipType       STATIC Der Text des Tooltips wird aus dem Attribut text entnommen (default)   DYNAMIC Der Text des Tooltips entspricht dem R\u00FCckgabewert der Methode String getlt;PropertyNamegt;ToolTip(). Der Wert von text wird in diesem Fall nicht ber\u00FCcksichtigt.        Tip   Tooltips k\u00F6nnen nur f\u00FCr Felder und Buttons erstellt werden.      ", "tags": "", "url": "../05_ui_komponenten/02_tooltips.html"},{"title": "Tabellen", "text": " Tabellen  Die Grundlagen zur Erstellung von Tabellen wurden im Kapitel Erstellung eines UI bereits erkl\u00E4rt. In dieser Sektion werden die Definition der Tabellenstruktur, das ContainerPmolt;Tgt;, der SimpleItemSupplierlt;PMO, MOgt; und der TableFooter im Detail betrachtet.   Definition der Tabellenstruktur mit Row PMO  Die Struktur der Tabelle wird in einer PMO Klasse definiert, deren Instanzen Zeilen in der Tabelle darstellen. Diese Klassen werden deshalb also Row PMO bezeichnet.   Row PMO Klassen sind standard PMO#8217;s. Da sie allerdings keine Sections darstellen, sollen sie nicht mit @UISection annotiert sein.   Die UI-Element Annotationen definieren in diesem Fall eine Spalte der Tabelle. Eine Tabellenspalte, in der der Name einer Person angezeigt wird, kann z.B. wie folgt definiert werden:        @UITableColumn(expandRatio = 0.25F)     @UILabel(position = 10, label = Name)     public String getName() {         return person.getName();     }    @UITableColumn  Grunds\u00E4tzlich werden alle Properties eines PMO#8217;s in der Tabelle angezeigt. Mit der Annotation @UITableColumn kann die Spaltenbreite \u00FCber die Properties width (Pixel) oder expandRatio definiert werden.      Note   Werden beide Properties definiert, hat width die h\u00F6here Priort\u00E4t gegen\u00FCber expandRatio.        ContainerPmo  Als ContainerPmo wird eine Klasse bezeichnet, die das Interface ContainerPmolt;Tgt; implementiert, und mit @UISection annotiert ist. Die Hauptaufgabe des ContainerPmos ist die Bereitstellung der in der Tabelle anzuzeigenden PMO#8217;s.   Die Methode Listlt;Tgt; getItems() wird vom TableBinding aufgerufen um die Elemente der Tabelle hinzuzuf\u00FCgen. Es sollte immer die gleiche Instanz der Listlt;Tgt; zur\u00FCckgegeben werden. Der SimpleItemSupplier bietet daf\u00FCr Unterst\u00FCtzung.   Durch \u00FCberschreiben der default Methode int getPageLength() kann gesteuert werden, wieviele Zeilen angezeigt werden sollen. Per Default werden 15 Zeilen angezeigt. Es ist durchaus \u00FCblich, die Tabelle bis zu einer gewissen Anzahl an Zeilen 'wachsen' zu lassen und danach die Zeilenanzahl durch eine Obergrenze zu limitieren und danach das 'scrollen' f\u00FCr die Tabelle zu aktivieren. Wird 0 zur\u00FCckgegeben, w\u00E4chst die Tabelle dynamisch mit dem Inhalt. Es existiert somit keine Obergrenze.        @Override     public int getPageLength() {         return Math.min(ContainerPmo.DEFAULT_PAGE_LENGTH, getItems().size());     }    Die Spaltenstruktur der Tabelle wird anhand der Row PMO Klasse bestimmt, die von der Methode Classlt;? extends Tgt; getItemPmoClass zur\u00FCckgegeben wird. In der Default-Implementierung wird die Klasse des Generic Parameters T zur\u00FCckgegeben. F\u00FCr Tabellen, die die gleiche Zeilen anzeigen, jedoch andere Spalten besitzen sollen,  kann also diese Methode \u00FCberschrieben werden um eine Subklasse von T zu verwenden.   Wenn die Tabelle das hinzuf\u00FCgen von Items unterst\u00FCtzen soll, muss die default Methode Optionallt;ButtonPmogt; getAddItemButtonPmo \u00FCberschrieben werden. Wie ein ButtonPmo im Detail erzeugt werden kann ist im Kapitel ButtonPmo beschrieben.    SimpleItemSupplier  Der SimpleItemSupplierlt;PMO, MOgt; wird verwendet, um nur dann eine neue Listlt;PMOgt; zu erstellen, wenn sich eine Zeile ver\u00E4ndert hat.   Die Instanzierung erfolgt mit 2 Parametern:     modelObjectSupplier vom Typ Supplierlt;Listlt;MOgt;gt; wird aufgerufen um auf die Liste der Modell-Objekte zuzugreifen   mo2pmoMapping vom Typ Functionlt;MO, PMOgt; wird f\u00FCr die Erzeugung eines PMO#8217;s f\u00FCr ein Modell-Objekt aufgerufen     Beispiel Initialisierung eines SimpleItemSuppliers      public PersonTablePmo(Listlt;Persongt; persons, Consumerlt;Persongt; editAction, Consumerlt;Persongt; deleteAction) {         items = new SimpleItemSupplierlt;gt;(() -gt; persons,                                          p -gt; new PersonRowPmo(p, editAction, deleteAction));     }     TableFooterPmo  Durch \u00FCberschreiben der default Methode getFooterPmo() wird eine Fu\u00DFzeile erzeugt. Die Implementierung des interfaces TableFooterPmo muss die Methode getFooterText(String column) implementieren.   Der Parameter column ist die ID der Spalte f\u00FCr die der Text angezeigt werden soll. Als Beispiel kann die Summe einer bestimmten Spalte aller Items in der Tabelle angezeigt werden.        private final TableFooterPmo footer;      public CarTablePmo(Listlt;Cargt; carStorage, Handler addCarAction) {         this.addCarAction = addCarAction;         this.items = new SimpleItemSupplierlt;gt;(() -gt; carStorage, CarRowPmo::new);          this.footer = c -gt; calculateTotalRetention(c, carStorage);     }      @Override     public Optionallt;TableFooterPmogt; getFooterPmo() {         return Optional.of(footer);     }      private String calculateTotalRetention(String column, Listlt;Cargt; cars) {          switch (column) {             case Car.PROPERTY_RETENTION:                  return String.format(%,.2f, cars.stream()                         .mapToDouble(Car::getRetention)                         .sum());              case Car.PROPERTY_CAR_TYPE:                  return Total Retention:;              default:                  return ;         }     }     ButtonPmo  Das ContainerPmo bietet momentan eine Methode getAddItemButtonPmo() an, womit ein Plusbutton neben dem Namen der Tabelle hinzugef\u00FCgt werden kann. Dieser Teil der API wird mit dem Issue LIN-128 \u00FCberarbeitet.   ", "tags": "", "url": "../05_ui_komponenten/03_tabellen.html"},{"title": "Read Me [ENG]", "text": " Read Me [ENG]  A data binding framework for web based user interfaces with Vaadin.   Features  Commonly applications consist of a variety of input elements that closely mirror objects and properties of a domain model. Creating such user interfaces and implementing the synchronization with the domain model is often a repetitive task. linkki automates most of the data binding tasks, enabling developers to focus on the domain- and UI logic.     Fast UI development   Declarative UI definition (with annotations)   UI logic implementation using the presentation model pattern (PMO)   automatic data binding between (P)MO and UI elements   dynamic binding of other UI properties, including    visibility   enabled-state   list of available values         Examples    Model Binding       @ModelObject     public Report getReport() {         return report;     }     Textfield/Textarea       @UITextArea(position = 10, label = Description, modelAttribute = description, required = RequiredType.REQUIRED, rows = 5, columns = 50)     public void description() {         /* Use description from report (model object) directly */     }     ComboBox       @UIComboBox(position = 20, label = Type, modelAttribute = type, required = RequiredType.REQUIRED)     public void type() {         /*          * - bind value to the property type from report - use enum constants from ReportType as          * available values          */     }     Button       @UIButton(position = 30, caption = Send, icon = FontAwesome.SEND, showIcon = true, enabled = EnabledType.DYNAMIC)     public void send() {         report.save();         Notification.show(                           String.format(Report with id %d filed!, report.getId()),                           Thank you for reporting!,                           Notification.Type.TRAY_NOTIFICATION);     }      /**      * Enable button only if description and type is present.      *      * @return {@code true} if button is enabled otherwise {@code false}      */     public boolean isSendEnabled() {         String description = report.getDescription();         return description != null amp;amp; !description.isEmpty()                 amp;amp; report.getType() != null;     } }       Figure 1. Report with disabled Send-Button      Figure 2. Report with enabled Send-Button      Note   the complete example can be found at TODO samples/getting-started.       Installation  linkki is available from Maven Central and can be included via Maven/Gradle:   maven dependency  lt;dependencygt;   lt;groupIdgt;org.linkkilt;/groupIdgt;   lt;artifactIdgt;linkki-corelt;/artifactIdgt;   lt;versiongt;${linkki.version}lt;/versiongt; lt;/dependencygt;    To compile linkki, check out the project from github. The used build tool is Apache Maven.    $gt; mvn clean install     Contribution    Bug reports, new ideas and improvements can be created in the TODO github issue tracker   Collaboration on issues/tasks via pull requests      Documentation  Reference documentation:   API documentation:    License  Copyright 2017 Faktor Zehn   Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.   ", "tags": "", "url": "../readme/README_ENG.html"},{"title": "Read Me [GER]", "text": " Read Me [GER]  Ein Data-Binding Framework f\u00FCr webbasierte Benutzeroberfl\u00E4chen mit Vaadin.   Features  H\u00E4ufig bestehen Applikationen aus vielen Eingabeelementen, die direkt Objekte und Eigenschaften aus dem Dom\u00E4nenmodell widerspiegeln. Die Erstellung solcher Oberfl\u00E4chen, sowie die Implementierung der Synchronisierung mit den Modellobjekten, ist oft eine repetitive Aufgabe. linkki \u00FCbernimmt die Aufgabe dieses Data-Bindings weitestgehend. So k\u00F6nnen sich Entwickler auf das Dom\u00E4nenmodell und die UI Logik konzentrieren.     Schnelle Erstellung von UIs   Deklarative UI Definition (\u00FCber Annotationen)   Implementierung der UI Logik \u00FCber ein PresentationModel (PMO)   Automatisches Data-Binding zwischen (P)MO und UI-Elementen   Dynamisches Binding weiterer UI Eigenschaften, u.A.    Sichtbarkeit (visible)   Aktivierungszustand (enabled)   Liste der ausw\u00E4hlbaren Werte         Beispiele  Model Binding       @ModelObject     public Report getReport() {         return report;     }      Textfeld/Textarea       @UITextArea(position = 10, label = Description, modelAttribute = description, required = RequiredType.REQUIRED, rows = 5, columns = 50)     public void description() {         /* Use description from report (model object) directly */     }    ComboBox       @UIComboBox(position = 20, label = Type, modelAttribute = type, required = RequiredType.REQUIRED)     public void type() {         /*          * - bind value to the property type from report - use enum constants from ReportType as          * available values          */     }     Button       @UIButton(position = 30, caption = Send, icon = FontAwesome.SEND, showIcon = true, enabled = EnabledType.DYNAMIC)     public void send() {         report.save();         Notification.show(                           String.format(Report with id %d filed!, report.getId()),                           Thank you for reporting!,                           Notification.Type.TRAY_NOTIFICATION);     }      /**      * Enable button only if description and type is present.      *      * @return {@code true} if button is enabled otherwise {@code false}      */     public boolean isSendEnabled() {         String description = report.getDescription();         return description != null amp;amp; !description.isEmpty()                 amp;amp; report.getType() != null;     } }       Figure 1. Report with disabled Send-Button      Figure 2. Report with enabled Send-Button      Note   das komplette Beispiel ist unter TODO samples/getting-started zu finden.        Installation  linkki steht auf Maven Central zur Verf\u00FCgung und kann \u00FCber Maven/Gradle eingebunden werden:   maven dependency  lt;dependencygt;   lt;groupIdgt;org.linkkilt;/groupIdgt;   lt;artifactIdgt;linkki-corelt;/artifactIdgt;   lt;versiongt;${linkki.version}lt;/versiongt; lt;/dependencygt;    Um linkki selbst zu kompilieren, muss das Projekt \u00FCber github ausgecheckt werden. Als Build-Tool wird Apache Maven verwendet.    $gt; mvn clean install     Contribution    Bugreports, neue Ideen und Erweiterungen k\u00F6nnen im TODO github issue tracker angelegt werden   Mitarbeit an den Issues/Tasks mittels Pull-Requests      Dokumentation  Referenz Dokumentation:   API Dokumentation:    Lizenz  Copyright 2017 Faktor Zehn   Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.   ", "tags": "", "url": "../readme/README_GER.html"},]};