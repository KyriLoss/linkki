var tipuesearch = {"pages": [{"title": "BindingContext Basics", "text": " Binding, BindingContext, BindingManager  For each UI component bound to a PMO, linkki creates a so called binding. The methods of this binding ensure that subsequent changes in the PMO lead to an update of the UI component.   All bindings in linkki are part of a BindingContext. Typically a BindingContext contains all bindings of a page or a section with independent content. Changes to a bound object (PMO or UI) trigger an update of all bindings in the same context. Multiple PMOs can be bound to the same BindingContext.      Figure 1. BindingContext and ~Manager   To create and manage one or more BindingContexts, a BindingManager is used. For a given name (for instance derived from a class) it returns a BindingContext, creating a new one when necessary. The desired binding behavior can be defined in subclasses of BindingManager (see Vertical Binding). If no special behavior needs to be implemented, a DefaultBindingManager can be used. A BindingManager is typically created @ViewScoped and passed to each Page (see Page).   DialogBindingManager is a special BindingManager, which triggers a validation method for each change of the dialog.  ", "tags": "", "url": "../03_architektur/01_grundaufbau_bindingcontext_bindingmanager.html"},{"title": "Data Binding with PMOs", "text": " Data Binding with PMOs  A Presentation Model Object encapsulates the UI state independently of the concrete UI implementation. The UI interacts exclusively via Data Binding with this PMO. The PMO isn#8217;t required to hold all data, it can delegate to existing model objects (see Data on Multiple Layers). This data is then converted into a format suitable for presentation.   In linkki PMOs are Plain Old Java Objects (POJOs), in which data for individual UI sections are structured. There should be a PMO for each UI section.   Of importance for the data binding are the so called Properties of a PMO. A PMO class has a property named property if and only if that class has a method getProperty. If the value of this property is to be modifiable, the method setProperty must exist. The value of the property is often stored in a field property. This follows the naming convention of JavaBean properties. However, PMO classes are not required to be JavaBeans.   See the following example class:    public class BeispielPmo {      private String nachname;     private String anrede;      public void setNachname(String nachname) {         this.nachname = nachname;     }      public String getAnrede() {         return anrede;     }      public void setAnrede(String anrede) {         this.anrede = anrede;     }      public String getNamensanzeige() {         return String.join( , anrede, nachname);     } }    This class has two properties: anrede and namensanzeige. The property namensanzeige shows, that for a PMO property there doesn#8217;t necessarily have to exist a corresponding field. Also, nachname is no property even though there is a field and a matching setter method, because the required method String getNachname() is missing.   There are some optional interfaces that PMO classes may implement:     org.linkki.core.PresentationModelObject offers a method for the creation of a button PMO. This button is displayed in the section header if the PMO is used with create UI with @UISection.   org.linkki.core.ButtonPmo is a PMO for buttons, see Buttons   org.linkki.core.ui.table.ContainerPmo is a PMO for tables, of which each row is represented by regular PMOs. See Container Components    ", "tags": "", "url": "../03_architektur/02_data_binding_mit_pmos.html"},{"title": "Data on Multiple Layers", "text": " Data on Multiple Layers (Domain Model Binding)  Domain Model Binding, model binding for short, is a linkki feature for reducing delegate code in PMO classes. It is aimed at the simple case of UI binding, in which properties from the domain model are directly presented in the UI, meaning that no special formatting or conversion needs to take place before the value can be shown.   To use this feature, the UI needs to be created via @UISection, and the getter method for the model object in the PMO needs to be marked with the @ModelObject annotation.        @ModelObject     public Person getPerson() {         return person;     }    For example, the Vorname property from the model can be used without conversion in the UI:        @UITextField(position = 10, label = Vorname)     public String getVorname() {         return getPerson().getFirstname();     }    In this case the getter method ensures a direct delegation to the model attribute. Therefore, the same behavior can be achieved using the model binding:        @UITextField(position = 10, label = Vorname, modelAttribute = firstname)     public void vorname() {      }    Model binding avoids unnecessary code dealing with delegation and is thus a shortcut.      Figure 1. Model Binding   Names of Model Attributes  To use the model binding feature, the property modelAttribute must be set in the UI Annotation. The data type of the property is String. The value of modelAttribute defines the name of the corresponding property in the domain model class. If no matching property exists in the domain model class, an exception is thrown during generation of the UI.   If modelAttribute is given, linkki ignores the return value and the body of the method in the PMO. Therefore the method body can remain empty and the return type be void. The data binding will skip the PMO method and call the corresponding method in the domain model directly.   In the example above the method in the PersonPMO is called vorname(). In the domain model, however, it is called firstname or getFirstname(). It is possible to name properties in PMO and domain model differently.      Tip   linkki searches the model for all required methods. If the setter method exists in the model but needs to be ignored in the UI, the shortcut cannot be used. Model attributes can also be set on annotated getter methods. In that case linkki searches for all methods in the model that it can#8217;t find in the PMO.      If the modelAttribute is set in the annotation of a non getter method, the whole method name is treated as a PMO property. This name is then used to bind UI Properties such as enabled state, visibility or available values.    Multiple Model Objects  Model binding can also be used if a PMO has multiple model objects. In this case, the property modelObject can be set in the UI annotation. The value of modelObject defines which model object of the PMO should be used for model binding. As identifier of model objects the name given in the @ModelObject annotation is used.    @UISection public class ContractSectionPmo {      private final Contract contract;       public ContractSectionPmo(Contract contract) {         this.contract = contract;     }       @ModelObject     public Person getPolicyHolder() {         return contract.getPolicyHolder();     }      @ModelObject(name = VP)     public Person getInsuredPerson() {         return contract.getInsuredPerson();     }       @UITextField(position = 10, label = Vorname VN, modelAttribute = firstname)     public void vornameVersicherungsnehmer() {     }      @UITextField(position = 20, label = Vorname VP, modelAttribute = firstname, modelObject = VP)     public void vornameVersichertePerson() {     }  }    In the example above the annotation of vornameVersichertePerson() defines that the property firstname on model object VP shall be called. To determine the value for the presentation on the UI, the data binding proceeds as follows:     Call the method getInsuredPerson() on the PMO, as that method is annotated with @ModelObject(VP)   Save the returned Person object   Call the getter method for firstname on the found Person object     If the annotation contains no property modelObject, the method annotated with @ModelObject (without name) is called. Correspondingly the model object for vornameVersicherungsnehmer() is determined via getPolicyHolder().   For situations where a method annotated with @ModelObject returns null, further getter method may have to be implemented. These methods must delegate to the existing model object or return default values if the model object is unavailable. The setter methods do not have to be implemented explicitly. The fields are treated as read only as long as no model object exists. As soon as one is available, the model object#8217;s setter method is called automatically.   ", "tags": "", "url": "../03_architektur/03_daten_auf_mehreren_ebenen.html"},{"title": "Binding further UI properties", "text": " Binding of Further UI Element Properties  Besides the value to be shown on the UI, further properties of UI elements can be bound to PMO methods via data binding. The function is described in the chapter UI Components.  ", "tags": "", "url": "../03_architektur/04_binding_von_weiteren_ui-element-eigenschaften.html"},{"title": "Cross-Sectional Data Binding", "text": " Cross-Sectional Data Binding  Although the state of the UI can be mostly defined by information from PMOs and the domain model, it sometimes must be additionaly influenced by other factors, such as system state, for instance. These factors are dealt with via cross-sectional data binding.   A good example for such aspects is the browse mode. Many applications distinguish between:     Edit Mode, in which data can be entered and modified on the UI   Browse Mode, in which data in forms is shown, but can#8217;t be modified     Often, applications toggle between these modes, for instance when Editing is started and completed. In browse mode all form fields should be read-only. This global editing state of the application thus influences many fields at once. Additionally, the browse mode overrides settings from PMOs. Even when a field is marked as editable by the PMO, it is write protected during browse mode.   linkki provides two technical means to implement cross-sectional data binding: PropertyDispatcher and PropertyBehaviors.   PropertyDispatcher  The BindingContext (see BindingContext Basics - BindingManager) uses a PropertyDispatcherFactory, which creates multiple linked PropertyDispatchers. These dispatchers in turn are used to bind PMO properties (see Binding of further UI element properties). PropertyDispatchers have methods to determine the data type and value of a property. By default linkki creates four linked dispatchers, where each delegates to the next if it can#8217;t provide the value:     BehaviorDependentDispatcher uses PropertyBehaviors (see next section, PropertyBehaviors)   BindingAnnotationDispatcher provides information that can be read directly from UI annotations   ReflectionPropertyDispatcher uses reflection to access methods on PMO or domain model derived from property names   ExceptionPropertyDispatcher throws an exception if the required property is not found. This often indicates a spelling error in the method name, which causes the ReflectionPropertyDispatcher to be unable to find the proper method        Figure 1. Example for PropertyDispatcher   Custom dispatchers can be created via a PropertyDispatcherFactory (in its own BindingContext). There the method createCustomDispatchers must be overwritten to create one or more custom dispatchers. These dispatchers are inserted between BehaviorDependentDispatcher and BindingAnnotationDispatcher.    PropertyBehaviors  PropertyBehaviors are created by a PropertyBehaviorProvider that can be passed to a BindingContext as constructor parameter. In this way, the application can configure which PropertyBehaviors should be used in the BindingContext.   A BehaviorDependentDispatcher can control the behavior of properties through PropertyBehaviors. Only a selection of properties can be controlled with it: Visibility (isVisible), editability (isWritable) and visibility of errors (isShowValidationMessages). For this, all PropertyBehaviors are called; if all return true, the BehaviorDependentDispatcher sends the request to the next PropertyDispatcher, otherwise it returns false or an empty error list, or doesn#8217;t set the value.      Figure 2. Veto of a PropertyBehaviors   For custom behaviors the interface PropertyBehavior can be implemented. That way, an entire page can be set into the editing or read-only mode:    class ReadOnlyBehavior implements PropertyBehavior {      private boolean editable;      public ReadOnlyBehavior(boolean editable) {        this.editable = editable;     }      @Override     public boolean isWritable(Object boundObject, String property) {         return editable;     } }    ", "tags": "", "url": "../03_architektur/05_querschnittsaspekte_im_databinding.html"},{"title": "Section", "text": " Section  A group of input fields or a table is called a Section. A section can have a title and when it does it is visually delimited by a line in the title bar. Without a title, a section isn#8217;t directly recognizable in the layout.   A section also defines in which arrangement the content should be displayed: Horizontal or vertical. With the horizontal layout all input fields are displayed on a line, side by side. With the vertical layout fields are displayed one below the other. If additionally a number of columns are defined with the property columns, a kind of grid layout is produced, row by row.   A section can contain a table instead of multiple input fields and is then called a TableSection.   SectionID  Each HTML element of a section can be accessed via ID. This can be used, for instance, to identify a section for UI testing. By default the SimpleName of the class is used as ID. Alternatively the annotation '@SectionID' can be used to specify a method that returns the ID for the section.   A section that was annotated with '@SectionID', calls the specified method exactly once. It remains the same for the duration of the session and is not updated dynamically.   ", "tags": "", "url": "../04_erstellung_eines_ui/01_section.html"},{"title": "PMO with UI Section", "text": " PresentationModelObject with @UISection  When a class is annotated with @UISection, linkki takes control over the creation and arrangement of the defined components. Using annotations for the UI elements, certain aspects can be defined or controlled. The sections are created via SectionFactories.   The UI elements are bound either to the 'properties' of a ModelObject or a PMO. A detailed description can be found in the chapter Data on Multiple Layers.      Tip   In all cases, if the ModelObject or PMO doesn#8217;t have a corresponding setter, the field is readOnly.      In the first section the creation of a section for a 'standard' form is exemplified. In the second section the creation of a section with a table is detailed.   Binding of a Form  Binding with @ModelObject  @UISection public class PersonSectionPmo implements PresentationModelObject {      @ModelObject     public Person getPerson() {         return person;     }      @UITextField(position = 10, label = Firstname, required = RequiredType.REQUIRED, modelAttribute = firstname)     public void firstname() {         /* model binding only */ }      @UITextField(position = 20, label = Lastname, required = RequiredType.REQUIRED, modelAttribute = lastname)     public void lastname() {         /* model binding only */ }      @UIComboBox(position = 30, label = Gender, content = AvailableValuesType.ENUM_VALUES_EXCL_NULL, itemCaptionProvider = ToStringCaptionProvider.class)     public void gender() {         /* model binding only */ }  }       Tip   The definition of modelAttribute is optional if the property name in the ModelObject and the name of the annotated method are equal.       Binding of a Table  To create a section with a table the annotated class must implement org.linkki.core.ui.table.ContainerPmolt;Tgt;. The generic parameter T represents the type of the PMO to create a row in this table.    @UISection public class PersonTablePmo implements ContainerPmolt;PersonRowPmogt; {    The method getItems() returns the rows of the table in the form of the previously defined T 'row PMOs'.        @Override     public Listlt;PersonRowPmogt; getItems() {         return items.get();     }    In the interface ContainerPmolt;Tgt; additional default methods are defined. A detailed description can be found here.   The so called 'Row PMO' is a regular PMO as described in the first section. The only difference is that the UI elements are also annotated with @UITableColumn.        @UITableColumn(expandRatio = 0.25F)     @UILabel(position = 10, label = Name)     public String getName() {         return person.getName();     }    All UI elements can be used in tables. The binding of a @UIButton looks as follows:        @UITableColumn(expandRatio = 0.1F)     @UIToolTip(text = Edit)     @UIButton(position = 30, icon = FontAwesome.EDIT, showIcon = true)     public void edit() {         editAction.accept(person);     }       Note   In our example the elements of the table shall be presented as read-only. Therefore no direct binding of the ModelObject via the @ModelObject annotation is done.      ", "tags": "", "url": "../04_erstellung_eines_ui/02_presentationmodelobject_mit_uisection.html"},{"title": "Manual Binding With `@Bind`", "text": " Manual Binding With @Bind  Due to special requirements or custom Fields it is sometimes not possible to use the automatic creation via @UISection. For this case linkki offers the option of 'only' using the data binding. This way, control over creation, arrangement and configuration (e.g. setNullRepresentation() or setConverter()) of the component is kept.   To activate the manual binding the component must be marked with the @Bind annotation. Both fields and methods can be annotated. Supported types are:     com.vaadin.ui.Field   com.vaadin.ui.Label   com.vaadin.ui.Button     Then, the data binding can be created via the Binder.   @Bind on Fields  public class AddressFields {      @Bind(pmoProperty = street)     private final TextField streetTxt;      @Bind(pmoProperty = zip)     private final TextField zipTxt;      @Bind(pmoProperty = city)     private final TextField cityTxt;      @Bind(pmoProperty = country, availableValues = AvailableValuesType.DYNAMIC)     private final ComboBox countryCb;  }    @Bind on Methods      @Bind(pmoProperty = street)     public TextField getStreetTxt() {         return streetTxt;     }      @Bind(pmoProperty = zip)     public TextField getZipTxt() {         return zipTxt;     }      @Bind(pmoProperty = city)     public TextField getCityTxt() {         return cityTxt;     }      @Bind(pmoProperty = country, availableValues = AvailableValuesType.DYNAMIC)     public ComboBox getCountryCb() {         return countryCb;     }       Tip   When the data binding of a Vaadin component of a third party library should be used by linkki, it can be activated via inheritance of 'delegate proxies' and @Bind on the methods.      Binding Activation          new Binder(addressFields, addressPmo).setupBindings(context);    Here is a sample project with the different binding options.      Tip    Binding summary:     @UISection #8594; simple and quick template with limited configuration options   manual binding #8594; full control     linkki uses certain naming conventions. That way sources of errors and refactoring complexity are reduced.   The values used in the annotations for pmoProperty and modelAttribute should be defined as constants in the corresponding classes.      ", "tags": "", "url": "../04_erstellung_eines_ui/03_manuelles_binding_mit_bind.html"},{"title": "UI Element", "text": " UI Element  Both fields and buttons are UI elements. The following types are provided:   Table 1. Fields       UILabel Displaying of text   UITextField Field for single line text entry   UITextArea Area for multiline text entry   UIIntegerField, UIDoubleField Entry field for numbers   UICheckbox Control for boolean input   UIDateField Field for date entry with date picker   UICombobox Dropdown field with predefined options     Table 2. Buttons       UIButton A button that triggers an action when clicked     The type of a field can be determined dynamically. This mechanism is called dynamic field.   Annotations for fields and buttons must exist on methods in a PMO class. The main difference between fields and buttons is that fields are used for displaying and editing of values and thus are bound to a value via data binding. Therefore annotations for fields must exist on a getter method of a PMO property. Only if domain model binding is used the method can be named differently.   Buttons are not bound to a value, but to an annotated method. It represents an executable action which is called by the button click.   Properties  All UI elements have the following properties in common:     position: int   label: String   noLabel: boolean/showLabel: boolean   enabled: boolean (not configurable for all elements)   visible: boolean   required: boolean (not configurable for all elements)     Fields have additional properties that are required for the domain model binding:     modelObject: String   modelAttribute: String        Caution   position musst be specified. All other properties have default values.      Position  The position property defines the order of elements in the UI. The relative size of the value is deciding. Elements with smaller position are added to the a section first.      Tip   Gaps in the position numbering are allowed and common, to allow adding new UI elements at a later moment without needing to renumber all elements.       Label  Usually there is a label text for each UI element, that describes the element. The content of the label is defined by this attribute.   If no label should be shown (as opposed to an empty one), noLabel = true can be used.   An exception to this is the button, for which normally no label is displayed. The controlling property is showLabel, set to false by default. The displaying can be forced by setting it to true.      Note   If an independent label is needed, the UI element UILabel can be used.       Enabled  The property enabled controls whether a component is active/editable. The following configuration options are available:   Table 3. EnabledType       ENABLED the content of the element is modifiable in the UI (default)   DISABLED the content of the element is not modifiable in the UI   DYNAMIC whether the content is modifiable is controlled by the return value of the method boolean islt;PropertyNamegt;Enabled()        Note   A UILabel doesn#8217;t offer these options and is always ENABLED.       Visible  The property visible controls whether the component is visible. There are the following configuration options:   Table 4. VisibleType       VISIBLE the UI element is visible (default)   INVISIBLE the UI element is invisible   DYNAMIC whether the UI element is visible is controlled by the return value of thte method boolean islt;PropertyNamegt;Visible()      Required  The property required visually highlights required fields. The following configuration options are available:   Table 5. RequiredType       REQUIRED the UI element requires input (a value musst be entered/selected)   REQUIRED_IF_ENABLED the UI element requires input if it is enabled   NOT_REQUIRED input in the UI element is optional (default)   DYNAMIC whether the element requires input is controlled by the return value of the method boolean islt;PropertyNamegt;Required()        Note   UILabels und UIButtons do not offer these options and are always NOT_REQUIRED.         Warning   Fields marked as required are only visually highlighted. No validation is performed.       ModelObject and -Attribute  A field can be bound to an attribute of an existing model object using lt;lt;domain-model-binding, domain model binding. For this the properties modelAttribute and possibly modelObject are required. The function is described in the section names of model attributes.     UILabel  The annotation @UILabel generates an independent UI element displaying string content. In contrast to a deactivated UITextField its text is not framed by an input field. This annotation is equivalent to a com.vaadin.ui.Label.   The annotated method must return a value of String type. The return value defines what is shown as label.      Tip   A UILabel also has the additional property label. If a value is set to it the text would appear beside the UILabel.      HTML Content  The content of the label can be styled with HTML if htmlContent=true is specified.   Example HTML Label Content      @UILabel(position = 1, label = , htmlContent = true)     public String getGender() {         switch (person.getGender()) {             case FEMALE:                 return FontAwesome.FEMALE.getHtml();             case MALE:                 return FontAwesome.MALE.getHtml();              default:                 return FontAwesome.GENDERLESS.getHtml();         }      }     Styles  To style labels the property styleNames can be used to specify a list (actually a String[]) of CSS class names.     UICheckbox  A com.vaadin.ui.CheckBox, bound to a boolean property.    UITextField  A com.vaadin.ui.TextField for text entry. The annotation UITextfield has two additional properties:     columns: int   maxLength: int     The property columns defines the width of the text field. If no positive value is defined, all available space is used.   maxLength defines the maximum number of characters that can be entered or displayed in the field.    UITextArea  The annotation UITextArea corresponds to a com.vaadin.ui.TextArea. It is used for entering or displaying text that has more than one line.UITextArea has all the properties of the annotation UITextfield. In addition, it also has:     rows: int     The property rows defines the height of the UITextArea, not how many rows can be entered. Its default value is 1.    UIIntegerField and UIDoubleField  @UIInterfield and @UIDoubleField are text fields for displaying formatted numbers. Like @UITextField these annotations have the property maxLength.   The format can be defined with the property format: String, using the notation from java.text.NumberFormat.   If no format is specified for a UIIntegerField, linkki uses the default Java Integer NumberFormat (java.text.NumberFormat#getIntegerInstance(java.util.Locale)). In the case of UIDoubleField the format #,##0.00## is used by default. This format means that at least one digit is displayed before the decimal separator and two after, plus thousands separator. The documentation for the format definition can be looked up in the class java.text.DecimalFormat.    UIDateField  The annotation @UIDateField generates a date input field and corresponds to (com.vaadin.ui.DateField). It allows specifying a date format using the property dateFormat: String. If not date format is defined the format matching the Locale setting is used. linkki uses dd.MM.yyyy by default for german. For other languages DateFormat.SHORT from the JDK is used.      Tip   The property can return both java.time.LocalDate and org.joda.time.LocalDate.       UIComboBox  A @UIComboBox allows selection of a value from a list. It has three additional properties:     content: AvailableValuesType   width: String   itemCaptionProvider: Classlt;? extends ItemCaptionProviderlt;?gt;gt;          @UIComboBox(position = 20,             label = Model,             modelAttribute = Car.PROPERTY_MODEL,             required = RequiredType.REQUIRED_IF_ENABLED,             content = AvailableValuesType.DYNAMIC,             itemCaptionProvider = ToStringCaptionProvider.class)     public void model() {         /* model binding */     }    Content  The attribute content defines which values are available:   Table 6. AvailableValuesType       ENUM_VALUES_INCL_NULL the values of the combobox correspond to the values of the enum data type of the property, extended by the value null (default)   ENUM_VALUES_EXCL_NULL the values of the combobox correspond to the values of the enum data type of the property   DYNAMIC the values of the combobox are defined dynamically through the method Collectionlt;Tgt; getlt;PropertyNamegt;AvailableValues()   NO_VALUES this combobox has no selectable values      Width  The property width can be used to define the width of the combobox using CSS syntax (e.g. 25em or 100%). The default value is -1px, corresponding to the standard size given by Vaadin.    ItemCaptionProvider  For displaying the individual values in the combobox a org.linkki.core.ui.components.ItemCaptionProviderlt;Tgt; is used. By default it is a DefaultCaptionProvider that expects a method getName(). Via the property itemCaptionProvider an alternative implementation class can be specified. linkki offers two additional ones:     ToStringCaptionProvider: uses the `toString()`method of the elements   IdAndNameCaptionProvider: displays name and ID in the format name [ID] using the methods getName() and getId().       UISubsetChooser  For selection of multiple values from a list, linkki offers the @UISubsetChooser. In this UI control elements are selected by moving them from a list on the left to a list on the right. The display of the individual elements is similar to UIComboBox, but with a default of ToStringCaptionProvider. As with UICombobox the width can be defined via the property width.   The content of a SubsetChooser musst be specified with the method Collectionlt;Tgt; getlt;PropertyNamegt;AvailableValues(). The bound property must be of type Setlt;Tgt;.   The caption of both columns can be set through the properties leftColumnCaption: String and rightColumnCaption: String.    UICustomField  Other controls can also easily be generated and bound by linkki. For this the annotation @UICustomField is used.   The control class is specified with the property uiControl: Classlt;? extends Fieldlt;?gt;gt;. If the control inherits from com.vaadin.ui.AbstractSelect the values can be defined by content: AvailableValuesType like with UIComboBox.      Warning   @UICustomField only supports controls with a parameter-less constructor.      UICustomField Example: PasswordField      @UICustomField(position = 20, label = Password, required = RequiredType.REQUIRED, modelAttribute = User.PROPERTY_PASSWORD, uiControl = PasswordField.class)     public void password() {         // model binding     }     Dynamic Field  linkki allows for dynamic typing of an input field. In the following example Selbstbehalt should only be freely writable if Autotyp is set to STANDARD. Otherwise the user can only select values from a list:        @UIDoubleField(position = 30,             label = Retention,             modelAttribute = Car.PROPERTY_RETENTION,             required = RequiredType.REQUIRED_IF_ENABLED)     @UIComboBox(position = 30,             label = Retention,             modelAttribute = Car.PROPERTY_RETENTION,             required = RequiredType.REQUIRED_IF_ENABLED,             content = AvailableValuesType.DYNAMIC,             itemCaptionProvider = RetentionCaptionProvider.class)     public void retention() {         /* model binding */     }      public Listlt;Doublegt; getRetentionAvailableValues() {         return Arrays.asList(2_000.0, 5_000.0, 10_000.0);     }      public Classlt;?gt; getRetentionComponentType() {         return car.getCarType() == CarType.STANDARD ? UIDoubleField.class : UIComboBox.class;     }    The selectable UI elements are defined via annotations on the method, as is customary. They must, however, fullfill the following requirements, to allow the type to be determined dynamically:     the position in the UI* annotations must match   the label must have the same value     If the position values are identical but the label values differ, an exception is thrown.   Which UI element is displayed for each PMO instance is determined by the method Classlt;?gt; getlt;PropertyNamegt;ComponentType(). It returns the class of the UI*-Annotation for the UI control to be rendered.    Button  The annotation @UIButton is used to mark the method that should be executed with the click on the button.   Buttons are not bound to values. Since buttons therefore have no corresponding PMO property, the name of the annotated method is used to determine the associated methods. The behavior is similar to the  domain model binding, although buttons have no property modelAttribute.        @UIButton(position = 10, showIcon = true, icon = FontAwesome.SAVE, captionType = CaptionType.NONE, shortcutKeyCode = KeyCode.ENTER, enabled = EnabledType.DYNAMIC)     public void save() {         saveAction.apply();     }      public boolean isSaveEnabled() {         return canSaveSupplier.getAsBoolean();     }      @UIButton(position = 20, captionType = CaptionType.STATIC, caption = reset, styleNames = BaseTheme.BUTTON_LINK)     public void reset() {         resetAction.apply();     }    Contrary to other UI elements @UIButton doesn#8217;t have the property noLabel, but showLabel instead. The default value is false. Apart from the common properties, buttons have these additional ones:     caption: String   captionType: CaptionType   icon: FontAwesome   show-icon: boolean   styleNames: String[]   shortcutKeyCode: int   shortcutModifierKeys: int[]     Caption  The text shown on a button is called a caption. It is not to be confused with a Label, which usually appears besides the control. A button can have both a caption and a label text.     captionType: CaptionType     Table 7. CaptionType       STATIC the caption of the button is read from the attribute caption (default)   NONE the button has no caption   DYNAMIC the caption of the button is determined by the return value of the method String getlt;PropertyNamegt;Caption(). The value of the attribute caption is ignored.      Icon  Apart from captions buttons can be adorned with icons. For this the constants of the Vaadin class FontAwesome are used. For the icon to be displayed the property showIcon must be set true.    Style Names  Depending on the function buttons must be styled differently. A typical example for this is the link button, a button that looks like a link. For this purpose the annotation @UIButton has the property styleNames. The value of this property are the CSS class names that should apply to the button.    Key Bindings  Some buttons shouldn#8217;t be triggered only by mouse click, but also by key combinations. These can be specified with the properties shortcutModifierKeys and shortcutKeyCode. shortcutModifierKeys defines which keys must be pressed and held before the key in the shortcutKeyCode is pressed. For instance, in many applications saving is triggered with the shortcut combination Ctrl + s. In this case the Ctrl key is the modifier and the s key is the ShortcutKey.   In both properties individual keys are identified by integer values. The appropriate value for each key can be found in the Vaadin classes ModifierKey and KeyCode.    ", "tags": "", "url": "../05_ui_komponenten/01_ui_element.html"},{"title": "Tooltips", "text": " Tooltips  For displaying tooltips on UI elements linkki provides the annotation @UITooltip. This annotation can be added in the PMO binding to the method to which the UI element is bound. In the case of binding using the @Bind annotation, @UITooltip musst be written directly in the field annotated with @Bind.   The @UITooltip annotation has two properties:     text: String   toolTipType: ToolTipType     Text  This is the text displayed on ToolTipType.STATIC. Its default value is an empty string ().    ToolTipType  The following configuration options are available for ToolTipType:   Table 1. ToolTipType       STATIC the text of the tooltip is read from the attribute text (default)   DYNAMIC the text of the tooltip is determined by the return value of the method String getlt;PropertyNamegt;ToolTip(). The value of text is ignored.        Tip   Tooltips can only be added to fields and buttons.      ", "tags": "", "url": "../05_ui_komponenten/02_tooltips.html"},{"title": "Tables", "text": " Tables  The basics of table creation were already mentioned in the chapter binding of a table. This section details the definition of table structure, the ContainerPmolt;Tgt;, the SimpleItemSupplierlt;PMO, MOgt; and the TableFooter.   Definition of the table structure with a row PMO  The structure of the table is defined in a PMO class, whose instances represent rows in the table. Thus, these classes are called row PMOs.   Row PMO classes are standard PMOs, which do not represent sections and thus shouldn#8217;t be annotated with @UISection.   Here, the annotation UI element defines the column in the table. A column showing the name of a person, for instance, can be setup as follows:        @UITableColumn(expandRatio = 0.25F)     @UILabel(position = 10, label = Name)     public String getName() {         return person.getName();     }    @UITableColumn  By design all properties of a PMO are presented in the table. With the annotation @UITableColumn the column width can be set via the properties width (in pixels) or expandRatio.      Note   If both properties are set, width has a higher priority than expandRatio.        ContainerPmo  A ContainerPmo is a class that implements the interface ContainerPmolt;Tgt; and is annotated with @UISection. The main function of a ContainerPmo is providing the PMOs to be rendered in the table.   The method Listlt;Tgt; getItems() is called by the TableBinding to add the elements to the table. It should always return the same instance of Listlt;Tgt;. The SimpleItemSupplier offers support for that.   By overwriting the default method int getPageLength() the number of lines shown can be controlled. By default 15 lines are shown. It is a common tactic to allow tables to 'grow' to a certain size and then limit the number of lines while also enabling the scrolling for the table. If 0 is returned the table grows dynamically with the content, without limit.        @Override     public int getPageLength() {         return Math.min(ContainerPmo.DEFAULT_PAGE_LENGTH, getItems().size());     }    The column structure of the table is determined by the class row PMO, which is returned by the method Classlt;? extends Tgt; getItemPmoClass. In the default implementation the class of the generic parameter T is returned. For tables that should have the same rows but different columns, this method can be overwritten to use a subclass of T.   If the table should support the adding of items, the default method Optionallt;ButtonPmogt; getAddItemButtonPmo must be overwritten. How a ButtonPmo is created is described in the chapter ButtonPmo.    SimpleItemSupplier  The SimpleItemSupplierlt;PMO, MOgt; is used to only create a new Listlt;PMOgt;, if a row was changed.   The instancing is done with two parameters     modelObjectSupplier of type Supplierlt;Listlt;MOgt;gt; is called to access a list of the model objects   mo2pmoMapping of type Functionlt;MO, PMOgt; is called for the creation of a PMO for a model objects     Example initialising of a SimpleItemSuppliers      public PersonTablePmo(Listlt;Persongt; persons, Consumerlt;Persongt; editAction, Consumerlt;Persongt; deleteAction) {         items = new SimpleItemSupplierlt;gt;(() -gt; persons,                                          p -gt; new PersonRowPmo(p, editAction, deleteAction));     }     TableFooterPmo  By overwriting the default method getFooterPmo() a footer row is generated. The implementation of the interface TableFooterPmo must implement the method getFooterText(String column).   The parameter column is the ID of the column for which the text should be displayed. An example for this would be a sum of all items from a column.        private final TableFooterPmo footer;      public CarTablePmo(Listlt;Cargt; carStorage, Handler addCarAction) {         this.addCarAction = addCarAction;         this.items = new SimpleItemSupplierlt;gt;(() -gt; carStorage, CarRowPmo::new);          this.footer = c -gt; calculateTotalRetention(c, carStorage);     }      @Override     public Optionallt;TableFooterPmogt; getFooterPmo() {         return Optional.of(footer);     }      private String calculateTotalRetention(String column, Listlt;Cargt; cars) {          switch (column) {             case Car.PROPERTY_RETENTION:                  return String.format(%,.2f, cars.stream()                         .mapToDouble(Car::getRetention)                         .sum());              case Car.PROPERTY_CAR_TYPE:                  return Total Retention:;              default:                  return ;         }     }     ButtonPmo  Currently the ContainerPmo provides a method getAddItemButtonPmo(), by which a plus button can be added besides the name of the table. This part ofthe API is being refactored in the issue LIN-128.   ", "tags": "", "url": "../05_ui_komponenten/03_tabellen.html"},{"title": "Read Me [ENG]", "text": " Read Me [ENG]  A data binding framework for web based user interfaces with Vaadin.   Features  Commonly applications consist of a variety of input elements that closely mirror objects and properties of a domain model. Creating such user interfaces and implementing the synchronization with the domain model is often a repetitive task. linkki automates most of the data binding tasks, enabling developers to focus on the domain- and UI logic.     Fast UI development   Declarative UI definition (with annotations)   UI logic implementation using the presentation model pattern (PMO)   automatic data binding between (P)MO and UI elements   dynamic binding of other UI properties, including    visibility   enabled-state   list of available values         Examples    Model Binding       @ModelObject     public Report getReport() {         return report;     }     Textfield/Textarea       @UITextArea(position = 10, label = Description, modelAttribute = description, required = RequiredType.REQUIRED, rows = 5, columns = 50)     public void description() {         /* Use description from report (model object) directly */     }     ComboBox       @UIComboBox(position = 20, label = Type, modelAttribute = type, required = RequiredType.REQUIRED)     public void type() {         /*          * - bind value to the property type from report - use enum constants from ReportType as          * available values          */     }     Button       @UIButton(position = 30, caption = Send, icon = FontAwesome.SEND, showIcon = true, enabled = EnabledType.DYNAMIC)     public void send() {         report.save();         Notification.show(                           String.format(Report with id %d filed!, report.getId()),                           Thank you for reporting!,                           Notification.Type.TRAY_NOTIFICATION);     }      /**      * Enable button only if description and type is present.      *      * @return {@code true} if button is enabled otherwise {@code false}      */     public boolean isSendEnabled() {         String description = report.getDescription();         return description != null amp;amp; !description.isEmpty()                 amp;amp; report.getType() != null;     } }       Figure 1. Report with disabled Send-Button      Figure 2. Report with enabled Send-Button      Note   the complete example can be found at TODO samples/getting-started.       Installation  linkki is available from Maven Central and can be included via Maven/Gradle:   maven dependency  lt;dependencygt;   lt;groupIdgt;org.linkkilt;/groupIdgt;   lt;artifactIdgt;linkki-corelt;/artifactIdgt;   lt;versiongt;${linkki.version}lt;/versiongt; lt;/dependencygt;    To compile linkki, check out the project from github. The used build tool is Apache Maven.    $gt; mvn clean install     Contribution    Bug reports, new ideas and improvements can be created in the TODO github issue tracker   Collaboration on issues/tasks via pull requests      Documentation  Reference documentation:   API documentation:    License  Copyright 2017 Faktor Zehn   Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.   ", "tags": "", "url": "../readme/README_ENG.html"},{"title": "Read Me [GER]", "text": " Read Me [GER]  Ein Data-Binding Framework f\u00FCr webbasierte Benutzeroberfl\u00E4chen mit Vaadin.   Features  H\u00E4ufig bestehen Applikationen aus vielen Eingabeelementen, die direkt Objekte und Eigenschaften aus dem Dom\u00E4nenmodell widerspiegeln. Die Erstellung solcher Oberfl\u00E4chen, sowie die Implementierung der Synchronisierung mit den Modellobjekten, ist oft eine repetitive Aufgabe. linkki \u00FCbernimmt die Aufgabe dieses Data-Bindings weitestgehend. So k\u00F6nnen sich Entwickler auf das Dom\u00E4nenmodell und die UI Logik konzentrieren.     Schnelle Erstellung von UIs   Deklarative UI Definition (\u00FCber Annotationen)   Implementierung der UI Logik \u00FCber ein PresentationModel (PMO)   Automatisches Data-Binding zwischen (P)MO und UI-Elementen   Dynamisches Binding weiterer UI Eigenschaften, u.A.    Sichtbarkeit (visible)   Aktivierungszustand (enabled)   Liste der ausw\u00E4hlbaren Werte         Beispiele  Model Binding       @ModelObject     public Report getReport() {         return report;     }      Textfeld/Textarea       @UITextArea(position = 10, label = Description, modelAttribute = description, required = RequiredType.REQUIRED, rows = 5, columns = 50)     public void description() {         /* Use description from report (model object) directly */     }    ComboBox       @UIComboBox(position = 20, label = Type, modelAttribute = type, required = RequiredType.REQUIRED)     public void type() {         /*          * - bind value to the property type from report - use enum constants from ReportType as          * available values          */     }     Button       @UIButton(position = 30, caption = Send, icon = FontAwesome.SEND, showIcon = true, enabled = EnabledType.DYNAMIC)     public void send() {         report.save();         Notification.show(                           String.format(Report with id %d filed!, report.getId()),                           Thank you for reporting!,                           Notification.Type.TRAY_NOTIFICATION);     }      /**      * Enable button only if description and type is present.      *      * @return {@code true} if button is enabled otherwise {@code false}      */     public boolean isSendEnabled() {         String description = report.getDescription();         return description != null amp;amp; !description.isEmpty()                 amp;amp; report.getType() != null;     } }       Figure 1. Report with disabled Send-Button      Figure 2. Report with enabled Send-Button      Note   das komplette Beispiel ist unter TODO samples/getting-started zu finden.        Installation  linkki steht auf Maven Central zur Verf\u00FCgung und kann \u00FCber Maven/Gradle eingebunden werden:   maven dependency  lt;dependencygt;   lt;groupIdgt;org.linkkilt;/groupIdgt;   lt;artifactIdgt;linkki-corelt;/artifactIdgt;   lt;versiongt;${linkki.version}lt;/versiongt; lt;/dependencygt;    Um linkki selbst zu kompilieren, muss das Projekt \u00FCber github ausgecheckt werden. Als Build-Tool wird Apache Maven verwendet.    $gt; mvn clean install     Contribution    Bugreports, neue Ideen und Erweiterungen k\u00F6nnen im TODO github issue tracker angelegt werden   Mitarbeit an den Issues/Tasks mittels Pull-Requests      Dokumentation  Referenz Dokumentation:   API Dokumentation:    Lizenz  Copyright 2017 Faktor Zehn   Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.   ", "tags": "", "url": "../readme/README_GER.html"},]};

