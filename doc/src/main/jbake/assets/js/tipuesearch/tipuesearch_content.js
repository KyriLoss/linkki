var tipuesearch = {"pages": [{"title": "Grundaufbau Binding Context - BindingManager", "text": " Grundaufbau Binding Context - Binding Manager  Alle Bindings in Linkki sind Teil eines BindingContext. \u00DCblicherweise verbindet ein BindingContext alle Bindings auf einer Seite oder in einem thematisch unabh\u00E4ngigen Abschnitt. Bei \u00C4nderungen an einem gebundenen Objekt (PMO oder UI) werden alle Bindings im gleichen Kontext aktualisiert. Mehrere PMOs (und damit UI-Abschnitte) k\u00F6nnen mit dem gleichen BindingContext gebunden werden.      Figure 1. BindingContext und ~Manager   Um einen oder mehrere BindingContext zu erstellen und zu verwalten, gibt es einen BindingManager. Dieser gibt zu einem Namen (ggf. abgeleitet von einer Klasse) einen BindingContext zur\u00FCck, oder erstellt bei Bedarf einen neuen. In Ableitungen von BindingManager kann festgelegt werden, welches Verhalten die vom jeweiligen BindingContext erstellten Bindings haben sollen (siehe Vertikales Binding). Soll kein besonderes Verhalten implementiert werden gen\u00FCgt ein DefaultBindingManager. Ein BindingManager wird \u00FCblicherweise @ViewScoped angelegt und jeder Page (siehe Page) \u00FCbergeben.   Ein besonderer BindingManager ist der DialogBindingManager, der daf\u00FCr sorgt, dass bei jeder \u00C4nderung auch die Validierungsmethode des Dialogs aufgerufen wird.  ", "tags": "", "url": "../03_architektur/01_grundaufbau_bindingcontext_bindingmanager.html"},{"title": "Data Binding mit PMOs", "text": " Data Binding mit PMOs  Ein Presentation Model Object kapselt den Zustand des UIs unabh\u00E4ngig von der konkreten UI-Implementierung. Das UI interagiert \u00FCber Data Binding ausschlie\u00DFlich mit diesem PMO. Dazu muss das PMO nicht alle Daten selber halten - h\u00E4ufig delegiert es an ein oder mehrere bestehende Modellobjekte (siehe Daten auf mehreren Ebenen) und/oder aggregiert und konvertiert Daten zur Darstellung im UI.      Figure 1. Presentation Model Object   In Linkki sind PMOs POJOs, die mit @UISection annotiert sind - es gibt also f\u00FCr jeden Abschnitt des UIs ein eigenes PMO. Alle an das UI zu bindenden Methoden erhalten passende Annotationen (siehe dazu UI Komponenten). Zus\u00E4tzlich gibt es ein paar Interfaces, die PMOs implementieren k\u00F6nnen:     org.linkki.core.PresentationModelObject bietet eine Methode, mit der ein Button-PMO erstellt werden kann; der daraus erzeugte Button l\u00F6st eine Bearbeitung des PMOs aus   org.linkki.core.ButtonPmo ist ein PMO f\u00FCr Buttons, siehe Buttons   org.linkki.core.ui.table.ContainerPmo ist ein PMO f\u00FCr Tabellen - die einzelnen Zeilen haben wieder regul\u00E4re PMOs, siehe auch Container Komponenten    ", "tags": "", "url": "../03_architektur/02_data_binding_mit_pmos.html"},{"title": "Daten auf mehreren Ebenen (Domain Model Binding)", "text": " Daten auf mehreren Ebenen (Domain Model Binding)  Domain Model Binding, oder kurz Model Binding, ist ein Linkki Feature zur Vermeidung unn\u00F6tigen Codes in PMO Klassen. Es zielt auf den einfachen Fall bei der Anbindung von UIs ab, in dem Eigenschaften aus dem Domain Model unver\u00E4ndert an der Oberfl\u00E4che angezeigt werden. Unver\u00E4ndert bedeutet, dass das PMO keine Umformattierung oder andere Konvertierungen durchf\u00FChren muss, bevor Werte in der UI angezeigt werden k\u00F6nnen.   Beispielsweise ben\u00F6tigt der Vorname einer Person keinerlei Umformattierung:        @UITextField(position = 10, label = Vorname)     public String getVorname() {         return getPerson().getFirstname();     }    Das selbe Verhalten unter Verwendung des Model Bindings:        @UITextField(position = 10, label = Vorname, modelAttribute = firstname)     public void vorname() {      }    Model Binding vermeidet unn\u00F6tigen Delegations-Code und ist damit eine Art Abk\u00FCrzung.      Figure 1. Model Binding   Namen von Modell-Attirbuten angeben  Um das Model Binding Feature verwenden zu k\u00F6nnen, muss in der UI Annotation die Eigenschaft modelAttribute angegeben werden. Der Datentyp der Eigenschaft ist String. Der Wert von modelAttribute gibt an, wie die entsprechende Property in der Domain Model Klasse hei\u00DFt. Existiert keine entsprechende Eigenschaft an der Domain Model Klasse, so wird bei der Erstellung der Oberfl\u00E4che eine Exception geworfen.   Sobald modelAttribute angegeben wird, ignoriert Linkki sowohl den R\u00FCckgabewert als auch den Inhalt der Methode im PMO. Daher kann als R\u00FCckgabetyp void angegeben, und der Methodenrumpf leer gelassen werden. Von nun an wird vom Data Binding nicht mehr die Methode im PMO aufgerufen, sondern immer direkt die entsprechende Methode im Domain Model.   Im obigen Beispiel hei\u00DFt die Methode im PersonPMO vorname(). Im Domain Model dagegen hei\u00DFt sie firstname bzw. getFirstname(). Es ist also m\u00F6glich, Properties in PMO und Domain Model unterschiedlich zu benennen.    Mehrere Modellobjekte  Model Binding kann auch dann zum Einsatz kommen, wenn ein PMO mehrere Modellobjekte verwendet. In diesem Fall kann in der UI Annotation die Eigenschaft modelObject angegeben werden. Der Datentyp der Eigenschaft ist ebenfalls String. Der Wert von modelObject gibt an, welches Model Object des PMOs f\u00FCr Model Binding verwendet werden soll. Als Identifikator von Modellobjekten wird der in der @ModelObject Annotation angegebene Name verwendet.    @UISection public class ContractPmo {      private final Contract contract;       public ContractPmo(Contract contract) {         this.contract = contract;     }       @ModelObject     public Person getPolicyHolder() {         return contract.getPolicyHolder();     }      @ModelObject(name = VP)     public Person getInsuredPerson() {         return contract.getInsuredPerson();     }       @UITextField(position = 10, label = Vorname VN, modelAttribute = firstname)     public void vornameVersicherungsnehmer() {     }      @UITextField(position = 20, label = Vorname VP, modelAttribute = firstname, modelObject = VP)     public void vornameVersichertePerson() {     }  }    Im obigen Beispiel definiert die Annotation von vornameVersichertePerson(), dass die Property firstname an Modellobjekt VP aufgerufen werden soll. Um einen Wert zur Darstellung in der Oberfl\u00E4che zu ermitteln, geht das Databinding folgenderma\u00DFen vor:     Aufrufen der Methode getInsuredPerson() am PMO, da diese Methode mit @ModelObject(VP) annotiert ist   Speichern des zur\u00FCckgegebenen Person-Objekts   Aufrufen des Getters f\u00FCr firstname am ermittelten Person-Objekt     Wird in der Annotation keine Eigenschaft modelObject angegeben, so wird die Methode aufgerufen, die mit @ModelObject (ohne weiteren Namen) annotiert wurde. Dementsprechend wird f\u00FCr vornameVersicherungsnehmer() das Modellobjekt \u00FCber getPolicyHolder() ermittelt.   ", "tags": "", "url": "../03_architektur/03_daten_auf_mehreren_ebenen.html"},{"title": "Binding von weiteren UI-Elment-Eigenschaften", "text": " Binding von weiteren UI-Element-Eigenschaften  Neben dem anzuzeigenden Wert k\u00F6nnen weitere Eigenschaften der UI-Elemente per Databinding an Methoden des PMO gebunden werden. Dazu bieten die UI-Annotationen ein paar Attribute an, die jeweils eine direkte Einstellung oder die dynamische Delegation an eine Methode erlauben. Die Namen der Methoden leiten sich jeweils aus dem Namen der gebundenen Property ab. Dieser ist, wenn angegeben, der Name des Modellattributs (siehe Namen von Modell-Attirbuten angeben), ansonsten wird er aus dem Methodennamen nach Java Bean Konvention abgeleitet (beginnt die Methode mit is oder get, so wird der Rest des Methodennamens mit klein geschriebenen erstem Buchstaben verwendet (getName() \u21D2 name), ansonsten der volle Methodenname (vorname() \u21D2 vorname)). Entsprechend der CamelCase-Konvention wird der erste Buchstabe in diesen Methoden wiederum gro\u00DF geschrieben.   Der jeweils fett markierte Wert ist der Default-Wert, der verwendet wird wenn das Attribut nicht angegeben wird.   Table 1. Eigenschaften        Attribut Enum-Wert Beschreibung     enabled EnabledType.ENABLED Der Inhalt des Elements ist im UI ver\u00E4nderbar   enabled EnabledType.DISABLED Der Inhalt des Elements ist im UI nicht ver\u00E4nderbar   enabled EnabledType.DYNAMIC Ob der Inhalt ver\u00E4nderbar ist h\u00E4ngt vom R\u00FCckgabewert der Methode boolean islt;PropertyNamegt;Enabled() ab   required RequiredType.REQUIRED Das UI-Element ist ein Pflichtfeld (ein Wert muss eingegeben/ausgew\u00E4hlt werden)   required RequiredType                .REQUIRED_IF_ENABLED Das UI-Element ist ein Pflichtfeld falls es enabled ist   required RequiredType.NOT_REQUIRED Das UI-Element ist ein optionales Feld   required RequiredType.DYNAMIC Ob das Feld ein Pflichtfeld ist h\u00E4ngt vom R\u00FCckgabewert der Methode boolean islt;PropertyNamegt;Required() ab   visible VisibleType.VISIBLE Das UI-Element ist sichtbar   visible VisibleType.INVISIBLE Das UI-Element ist unsichtbar   visible VisibleType.DYNAMIC Ob as UI-Element sichtbar ist h\u00E4ngt vom R\u00FCckgabewert der Methode boolean islt;PropertyNamegt;Visible() ab   captionType CaptionType.STATIC Der Text des Buttons wird aus dem Attribut caption entnommen   captionType CaptionType.NONE Der Button hat keinen Text   captionType CaptionType.DYNAMIC Der Text des Buttons entspricht dem R\u00FCckgabewert der Methode String getlt;PropertyNamegt;Caption()   toolTipType ToolTipType.STATIC Der Text des Tooltips wird aus dem Attribut text entnommen   toolTipType ToolTipType.DYNAMIC Der Text des Tooltips entspricht dem R\u00FCckgabewert der Methode String getlt;PropertyNamegt;ToolTip()   content AvailableValuesType               .ENUM_VALUES_INCL_NULL Die Werte in der Combobox entsprechen den Werten des Enum-Datentypen der Property erg\u00E4nzt um den Wert null   content AvailableValuesType               .ENUM_VALUES_EXCL_NULL Die Werte in der Combobox entsprechen den Werten des Enum-Datentypen der Property   content AvailableValuesType               .DYNAMIC Die Werte in der Combobox werden \u00FCber die Methode Listlt;Tgt; getlt;PropertyNamegt;AvailableValues() ermittelt   content AvailableValuesType               .NO_VALUES In dieser Combobox sind keine Werte ausw\u00E4hlbar     Nicht alle Eigenschaften sind bei allen Annotations verf\u00FCgbar.   Table 2. Zuordnung Eigenschaften zu UI-Annotations            Annotation enabled required visible captionType toolTipType content     UIButton \u2713  \u2713 \u2713     UICheckBox \u2713 \u2713 \u2713      UIComboBox \u2713 \u2713 \u2713   \u2713   UICustomField \u2713 \u2713 \u2713   \u2713   UIDateField \u2713 \u2713 \u2713      UIDecimalField \u2713 \u2713 \u2713      UIDoubleField \u2713 \u2713 \u2713      UIIntegerField \u2713 \u2713 \u2713      UILabel   \u2713      UITextArea \u2713 \u2713 \u2713      UITextField \u2713 \u2713 \u2713      UIToolTip     \u2713     ", "tags": "", "url": "../03_architektur/04_binding_von_weiteren_ui-element-eigenschaften.html"},{"title": "Querschnittsaspekte im Databinding", "text": " Querschnittsaspekte im Databinding  Zum Gro\u00DFteil bestimmen Informationen aus PMOs und Domain Model den Zustand der UI. In vielen Anwendungen jedoch muss die Oberfl\u00E4che zus\u00E4tzlich durch andere Informationen, z.B. den Systemzustand beeinflusst werden. Diese Informationen nennen wir im Folgenden Querschnittsaspekte.   Das Standardbeispiel f\u00FCr einen Querschnittsaspekt ist der Browse Mode. Viele Anwendungen unterscheiden zwischen:     Editiermodus (Edit Mode), in dem Informationen in der Oberfl\u00E4che eingegeben und ver\u00E4ndert werden k\u00F6nnen   Ansichtsmodus (Browse Mode), in dem Daten in Formularen zwar angezeigt werden, aber schreibgesch\u00FCtzt sind     H\u00E4ufig wechseln Anwendungen zwischen diesen Modi hin und her, z.B. indem eine \u00C4nderung begonnen oder abgeschlossen wird. Im Browse Mode gilt, dass alle Felder in Formularen schreibgesch\u00FCtzt sind. Dieser globale Bearbeitungszustand der Anwendung beeinflusst also viele Felder gleichzeitig. Zus\u00E4tzlich \u00FCberstimmt der Browse Mode die Einstellungen aus PMOs. Selbst wenn ein PMO ein Feld als editierbar angibt, ist es im Browse Mode schreibgesch\u00FCtzt.   Auf technischer Ebene existieren zwei Linkki-Konstrukte, um Querschnittsaspekte abzubilden: PropertyDispatcher und PropertyBehaviors.   PropertyDispatcher  Der BindingContext (siehe Grundaufbau BindingContext - BindingManager) verwendet eine PropertyDispatcherFactory, die mehrere miteinander verkn\u00FCpfte PropertyDispatcher erstellt. Diese Dispatcher wiederum werden zum Binden der Properties und ihrer Eigenschaften (siehe Binding von weiteren UI-Element-Eigenschaften) verwendet. PropertyDispatcher haben Methoden zur Abfrage von Datentyp und Wert einer Property, sowie der zugeh\u00F6rigen Eigenschaften. Standardm\u00E4\u00DFig werden in Linkki vier miteinander verkn\u00FCpfte Dispatcher erstellt, die jeweils an den N\u00E4chsten delegieren, wenn sie selbst den Wert nicht liefern k\u00F6nnen:     BehaviorDependentDispatcher verwendet PropertyBehaviors (siehe im n\u00E4chsten Abschnitt, PropertyBehaviors)   BindingAnnotationDispatcher liefert Informationen die aus den UI-Annotationen direkt abgelesen werden k\u00F6nnen   ReflectionPropertyDispatcher greift per Reflection auf die aus dem Propertynamen abgeleiteten Methoden am PMO bzw. Domain Model zu   ExceptionPropertyDispatcher wirft eine Exception, falls die entsprechende Eigenschaft nicht verf\u00FCgbar ist - dies deutet h\u00E4ufig auf einen Tippfehler in einem Methodennamen hin, aufgrunddessen der ReflectionPropertyDispatcher die passende Methode nicht finden kann        Figure 1. Beispiel f\u00FCr PropertyDispatcher   Eigene Dispatcher k\u00F6nnen \u00FCber eine eigene PropertyDispatcherFactory (in einem eigenen BindingContext) erstellt werden. Dort muss die Methode createCustomDispatchers \u00FCberschrieben werden, um einen oder mehrere eigene Dispatcher bereitzustellen. Diese anwendungsspezifischen Dispatcher werden zwischen BehaviorDependentDispatcher und BindingAnnotationDispatcher eingeh\u00E4ngt.    PropertyBehaviors  PropertyBehaviors werden von einem PropertyBehaviorProvider erstellt, der dem BindingContext als Konstruktor-Parameter \u00FCbergeben werden kann. Welche PropertyBehaviors verwendet werden, kann also von der Anwendung konfiguriert werden.   \u00DCber PropertyBehaviors kann ein BehaviorDependentDispatcher das Verhalten von Eigenschaften steuern. Nur eine Auswahl der Eigenschaften sind dar\u00FCber steuerbar: Sichtbarkeit (isVisible), Editierbarkeit (isWritable) und Anzeige von Fehlern (isShowValidationMessages). Dazu werden alle PropertyBehaviors aufgerufen; geben sie einstimmig true zur\u00FCck, leitet der BehaviorDependentDispatcher die Anfrage an den n\u00E4chsten PropertyDispatcher weiter, ansonsten gibt er direkt false bzw. eine leere Fehlerliste zur\u00FCck, oder setzt den Wert nicht.      Figure 2. Veto eines PropertyBehaviorsr   F\u00FCr eigene Verhaltensweisen kann das Interface PropertyBehavior implementiert werden. So kann zum Beispiel eine komplette Seite in einen Lese- oder Schreibmodus versetzt werden:    class ReadOnlyBehavior implements PropertyBehavior {      private boolean editable;      public ReadOnlyBehavior(boolean editable) {        this.editable = editable;     }      @Override     public boolean isWritable(Object boundObject, String property) {         return editable;     } }    ", "tags": "", "url": "../03_architektur/05_querschnittsaspekte_im_databinding.html"},{"title": "Section", "text": " Section  Eine Gruppe von Eingabefeldern oder eine Tabelle wird als Section bezeichnet. Eine Section kann einen Titel haben und wird in diesem Fall auch optisch durch eine Linie in der Titelleiste abgegrenzt. Wenn eine Section keinen Titel hat, ist sie optisch im flie\u00DFenden Layout nicht direkt zu erkennen.   Eine Section legt au\u00DFderdem fest, in welcher Anordnung der Inhalt dargestellt werden soll: horizontal oder vertikal. Im horizontalen Layout werden alle Eingabefelder in einer Zeile, nebeneinander dargestellt. Im vertikalen Layout werden die Felder untereinander dargetstellt. Wenn zus\u00E4tzlich eine Anzahl von Spalten durch die Eigenschaft columns festgelegt wird, wird zeilenweise (links-rechts) eine Art Grid Layout aufgebaut.   Die Section kann anstatt mehrere Eingabefelder auch eine Tabelle enthalten und wird dann als TableSection genannt.  ", "tags": "", "url": "../04_erstellung_eines_ui/01_section.html"},{"title": "Presentationmodelobject mit UI Section", "text": " Presentationmodelobject mit UI Section  Wird eine Klasse mit @UISection annotiert, \u00FCbernimmt linkki die Kontrolle \u00FCber die Erstellung und Anordnung der definierten Komponenten. \u00DCber die Annotation f\u00FCr die zugeh\u00F6rigen UIElemente k\u00F6nnen bestimmte Aspekte definiert und/oder gesteuert werden. Die Sections werden \u00FCber SectionFactories erstellt.   Die UIElemente werden entweder an die 'properties' eines ModelObjects oder eines PMO#8217;s gebunden. Eine detaillierte Beschreibung gibt es im Kapitel Daten auf mehreren Ebenen.   Im ersten Abschnitt wird die Erstellung einer Section eines 'standard' Formulars beschrieben. Im zweiten Abschnitt wird das erstellen einer Section mit einer Tabelle erleutert.   Binding eines Formulars  Binding mit @ModelObject  @UISection public class PersonPmo implements PresentationModelObject {      @ModelObject     public Person getPerson() {         return person;     }      @UITextField(position = 10, label = Firstname, required = RequiredType.REQUIRED, modelAttribute = firstname)     public void firstname() {         /* model binding only */ }      @UITextField(position = 20, label = Lastname, required = RequiredType.REQUIRED, modelAttribute = lastname)     public void lastname() {         /* model binding only */ }  }       Tip   die Definition von modelAttribute ist optional, wenn der Property Name im ModelObject und der Name der annotierten Methode gleich sind.       Binding einer Tabelle  Um eine Section mit einer Tabelle zu erzeugen muss die annotierte Klasse org.linkki.core.ui.table.ContainerPmolt;Tgt; implementieren. Der Generic-Parameter T repr\u00E4sentiert den Typ des PMOs um eine Zeile in dieser Tabelle zu erzeugen.    @UISection public class PersonTablePmo implements ContainerPmolt;PersonRowPmogt; {    Die Methode getItems() gibt die Zeilen der Tabelle in Form der vorher mit T spezifizierten 'Row PMOs' zur\u00FCck.        @Override     public Listlt;PersonRowPmogt; getItems() {         return items.get();     }    Im interface ContainerPmolt;Tgt; werden noch weitere default Methoden spezifiziert. Eine genaue Beschreibung befindet sich hier.   Das sogenannte 'Row PMO' ist grunds\u00E4tzliche ein gew\u00F6hnliches PMO wie in Abschnitt 1 beschrieben. Die einzige Besonderheit ist, dass die UIElemente ebenfalls mit der Annotation @UITableColumn gekennzeichnet sind.        @UITableColumn(expandRatio = 0.3F)     @UILabel(position = 10, label = Name)     public String getName() {         return person.getName();     }    Es k\u00F6nnen alle UIElemente ebenfalls in Tabellen verwendet werden. Ein Binding eines @UIButton sieht folgenderma\u00DFen aus:        @UITableColumn(expandRatio = 0.1F)     @UIToolTip(text = Edit)     @UIButton(position = 30, icon = FontAwesome.EDIT, showIcon = true)     public void edit() {         editAction.accept(person);     }       Note   In unserem Beispiel sollen die Elemente in der Tabelle 'read-only' dargestellt werden. Deswegen erfolgt kein direktes Binding des ModelObject \u00FCber eine mit @Model annotierte Methode.         Important   In allen F\u00E4llen gilt: existiert im ModelObject oder PMO kein 'Setter' dann ist das Feld readOnly      ", "tags": "", "url": "../04_erstellung_eines_ui/02_presentationmodelobject_mit_uisection.html"},{"title": "Manuelles Binding mit `@Bind`", "text": " Manuelles Binding mit @Bind  Auf Grund spezieller Anforderungen oder spezieller eigener Fields ist es manchmal nicht m\u00F6glich den automatischen Aufbau \u00FCber @UISection zu nutzen. F\u00FCr diesen Fall besteht die M\u00F6glichkeit, dass linkki 'nur' das Data-Binding \u00FCbernimmt. Man beh\u00E4lt somit die volle Kontrolle \u00FCber die Erstellung, Anordnung und Konfiguration (z.B. setNullRepresentation() oder setConverter()) der Komponenten.   F\u00FCr die Aktivierung des manuellen Bindings muss die Annotation @Bind auf die Komponente geschrieben werden. Es k\u00F6nnen sowohl Felder als auch Methoden annotiert werden. Unterst\u00FCtzte Typen sind:     com.vaadin.ui.Field   com.vaadin.ui.Label   com.vaadin.ui.Button     Danach kann das Data-Binding \u00FCber den Binder erstellt werden.   @Bind auf Felder  public class AddressFields {      @Bind(pmoProperty = street)     private final TextField streetTxt;      @Bind(pmoProperty = zip)     private final TextField zipTxt;      @Bind(pmoProperty = city)     private final TextField cityTxt;      @Bind(pmoProperty = country, availableValues = AvailableValuesType.DYNAMIC)     private final ComboBox countryCb;  }    @Bind auf Methoden      @Bind(pmoProperty = street)     public TextField getStreetTxt() {         return streetTxt;     }      @Bind(pmoProperty = zip)     public TextField getZipTxt() {         return zipTxt;     }      @Bind(pmoProperty = city)     public TextField getCityTxt() {         return cityTxt;     }      @Bind(pmoProperty = country, availableValues = AvailableValuesType.DYNAMIC)     public ComboBox getCountryCb() {         return countryCb;     }       Tip   wenn das Data-Binding von Vaadin-Komponenten einer verwendeten Library von linkki \u00FCbernommen werden soll, kann dies durch Vererbung oder 'delegete proxies' und @Bind auf den Methoden aktiviert werden.      Binding aktivieren          new Binder(addressFields, addressPmo).setupBindings(context);    Hier ist ein Beispielprojekt mit den verschiedenen Binding-M\u00F6glichkeiten.   Binding-Zusammenfassung:    @UISection #8594; einfaches, schnelles Template mit eingeschr\u00E4nkten Konfigurationsm\u00F6glichkeiten   manuelles Binding #8594; volle Kontrolle     linkki arbeitet mit bestimmten Namenskonventionen. Dadurch verringern sich die Fehlerquellen und der refactoring Aufwand.   Die in den Annotationen verwendeten Werte f\u00FCr pmoProperty bzw. modelAttribute sollten in Konstanten der jeweiligen Klasse ausgelagert werden.   ", "tags": "", "url": "../04_erstellung_eines_ui/03_manuelles_binding_mit_bind.html"},{"title": "UI Komponenten", "text": " UI Komponenten  Felder    Buttons   ", "tags": "", "url": "../05_ui_komponenten/05_ui_komponenten.html"},{"title": "Read Me [ENG]", "text": " Read Me [ENG]  A data binding framework for web based user interfaces with Vaadin.   Features  Commonly applications consist of a variety of input elements that closely mirror objects and properties of a domain model. Creating such user interfaces and implementing the synchronization with the domain model is often a repetitive task. linkki automates most of the data binding tasks, enabling developers to focus on the domain- and UI logic.     Fast UI development   Declarative UI definition (with annotations)   UI logic implementation using the presentation model pattern (PMO)   automatic data binding between (P)MO and UI elements   dynamic binding of other UI properties, including    visibility   enabled-state   list of available values         Examples    Model Binding       @ModelObject     public Report getReport() {         return report;     }     Textfield/Textarea       @UITextArea(position = 10, label = Description, modelAttribute = description, required = RequiredType.REQUIRED, rows = 5, columns = 50)     public void description() {         /* Use description from report (model object) directly */     }     ComboBox       @UIComboBox(position = 20, label = Type, modelAttribute = type, required = RequiredType.REQUIRED)     public void type() {         /*          * - bind value to the property type from report - use enum constants from ReportType as          * available values          */     }     Button       @UIButton(position = 30, caption = Send, icon = FontAwesome.SEND, showIcon = true, enabled = EnabledType.DYNAMIC)     public void send() {         report.save();         Notification.show(                           String.format(Report with id %d filed!, report.getId()),                           Thank you for reporting!,                           Notification.Type.TRAY_NOTIFICATION);     }      /**      * Enable button only if description and type is present.      *      * @return {@code true} if button is enabled otherwise {@code false}      */     public boolean isSendEnabled() {         String description = report.getDescription();         return description != null amp;amp; !description.isEmpty()                 amp;amp; report.getType() != null;     } }       Figure 1. Report with disabled Send-Button      Figure 2. Report with enabled Send-Button      Note   the complete example can be found at TODO samples/getting-started.       Installation  linkki is available from Maven Central and can be included via Maven/Gradle:   maven dependency  lt;dependencygt;   lt;groupIdgt;org.linkkilt;/groupIdgt;   lt;artifactIdgt;linkki-corelt;/artifactIdgt;   lt;versiongt;${linkki.version}lt;/versiongt; lt;/dependencygt;    To compile linkki, check out the project from github. The used build tool is Apache Maven.    $gt; mvn clean install     Contribution    Bug reports, new ideas and improvements can be created in the TODO github issue tracker   Collaboration on issues/tasks via pull requests      Documentation  Reference documentation:   API documentation:    License  Copyright 2017 Faktor Zehn   Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.   ", "tags": "", "url": "../readme/README_ENG.html"},{"title": "Read Me [GER]", "text": " Read Me [GER]  Ein Data-Binding Framework f\u00FCr webbasierte Benutzeroberfl\u00E4chen mit Vaadin.   Features  H\u00E4ufig bestehen Applikationen aus vielen Eingabeelementen, die direkt Objekte und Eigenschaften aus dem Dom\u00E4nenmodell widerspiegeln. Die Erstellung solcher Oberfl\u00E4chen, sowie die Implementierung der Synchronisierung mit den Modellobjekten, ist oft eine repetitive Aufgabe. linkki \u00FCbernimmt die Aufgabe dieses Data-Bindings weitestgehend. So k\u00F6nnen sich Entwickler auf das Dom\u00E4nenmodell und die UI Logik konzentrieren.     Schnelle Erstellung von UIs   Deklarative UI Definition (\u00FCber Annotationen)   Implementierung der UI Logik \u00FCber ein PresentationModel (PMO)   Automatisches Data-Binding zwischen (P)MO und UI Elementen   Dynamisches Binding weiterer UI Eigenschaften, u.A.    Sichtbarkeit (visible)   Aktivierungszustand (enabled)   Liste der ausw\u00E4hlbaren Werte         Beispiele  Model Binding       @ModelObject     public Report getReport() {         return report;     }      Textfeld/Textarea       @UITextArea(position = 10, label = Description, modelAttribute = description, required = RequiredType.REQUIRED, rows = 5, columns = 50)     public void description() {         /* Use description from report (model object) directly */     }    ComboBox       @UIComboBox(position = 20, label = Type, modelAttribute = type, required = RequiredType.REQUIRED)     public void type() {         /*          * - bind value to the property type from report - use enum constants from ReportType as          * available values          */     }     Button       @UIButton(position = 30, caption = Send, icon = FontAwesome.SEND, showIcon = true, enabled = EnabledType.DYNAMIC)     public void send() {         report.save();         Notification.show(                           String.format(Report with id %d filed!, report.getId()),                           Thank you for reporting!,                           Notification.Type.TRAY_NOTIFICATION);     }      /**      * Enable button only if description and type is present.      *      * @return {@code true} if button is enabled otherwise {@code false}      */     public boolean isSendEnabled() {         String description = report.getDescription();         return description != null amp;amp; !description.isEmpty()                 amp;amp; report.getType() != null;     } }       Figure 1. Report with disabled Send-Button      Figure 2. Report with enabled Send-Button      Note   das komplette Beispiel ist unter TODO samples/getting-started zu finden.        Installation  linkki steht auf Maven Central zur Verf\u00FCgung und kann \u00FCber Maven/Gradle eingebunden werden:   maven dependency  lt;dependencygt;   lt;groupIdgt;org.linkkilt;/groupIdgt;   lt;artifactIdgt;linkki-corelt;/artifactIdgt;   lt;versiongt;${linkki.version}lt;/versiongt; lt;/dependencygt;    Um linkki selbst zu kompilieren, muss das Projekt \u00FCber github ausgecheckt werden. Als Build-Tool wird Apache Maven verwendet.    $gt; mvn clean install     Contribution    Bugreports, neue Ideen und Erweiterungen k\u00F6nnen im TODO github issue tracker angelegt werden   Mitarbeit an den Issues/Tasks mittels Pull-Requests      Dokumentation  Referenz Dokumentation:   API Dokumentation:    Lizenz  Copyright 2017 Faktor Zehn   Licensed under the Apache License, Version 2.0 (the License); you may not use this file except in compliance with the License. You may obtain a copy of the License at   http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.   ", "tags": "", "url": "../readme/README_GER.html"},]};